<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoOracle Pro - AI Prediction Engine (Bybit)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-green: #00ff88;
            --neon-red: #ff3366;
            --neon-purple: #9945ff;
            --neon-blue: #00d4ff;
            --neon-orange: #ff9500;
            --glass-bg: rgba(15, 15, 35, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .cyber-grid {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .neon-glow-green { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3), 0 0 40px rgba(0, 255, 136, 0.1); }
        .neon-glow-red { box-shadow: 0 0 20px rgba(255, 51, 102, 0.3), 0 0 40px rgba(255, 51, 102, 0.1); }
        .neon-glow-purple { box-shadow: 0 0 20px rgba(153, 69, 255, 0.3), 0 0 40px rgba(153, 69, 255, 0.1); }

        .title-font { font-family: 'Orbitron', monospace; }

        .gauge-container { position: relative; width: 280px; height: 160px; }
        .gauge-bg { position: absolute; width: 100%; height: 100%; }
        .gauge-needle {
            position: absolute;
            bottom: 10px; left: 50%;
            width: 4px; height: 100px;
            background: linear-gradient(to top, #fff, transparent);
            transform-origin: bottom center;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 2px;
        }

        .param-block {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .param-block::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .param-block.bullish::before { background: radial-gradient(ellipse at center, var(--neon-green), transparent 70%); }
        .param-block.bearish::before { background: radial-gradient(ellipse at center, var(--neon-red), transparent 70%); }
        .param-block.neutral::before { background: radial-gradient(ellipse at center, var(--neon-purple), transparent 70%); }

        .crypto-tab { transition: all 0.3s ease; cursor: pointer; }
        .crypto-tab.active {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(153, 69, 255, 0.2));
            border-color: var(--neon-green);
        }

        .countdown-ring {
            stroke-dasharray: 283;
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear;
        }

        .prediction-card { transition: all 0.3s ease; }
        .prediction-card:hover { transform: translateY(-5px); }
        .prediction-card.locked { border: 1px solid var(--neon-purple); }

        .pulse-dot { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .scan-line {
            position: absolute;
            width: 100%; height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
            animation: scan 3s linear infinite;
        }

        @keyframes scan {
            0% { top: 0; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        .loading-bar {
            background: linear-gradient(90deg, var(--neon-green), var(--neon-purple), var(--neon-blue));
            background-size: 200% 100%;
            animation: loading 1.5s ease infinite;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        ::-webkit-scrollbar-thumb { background: var(--neon-purple); border-radius: 4px; }

        .leverage-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: linear-gradient(135deg, var(--neon-orange), var(--neon-red));
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
        }

        .connection-status.connected { background: rgba(0, 255, 136, 0.2); border: 1px solid rgba(0, 255, 136, 0.3); }
        .connection-status.disconnected { background: rgba(255, 51, 102, 0.2); border: 1px solid rgba(255, 51, 102, 0.3); }
        .connection-status.connecting { background: rgba(255, 149, 0, 0.2); border: 1px solid rgba(255, 149, 0, 0.3); }

        .funding-rate { font-size: 11px; padding: 2px 6px; border-radius: 4px; }
        .funding-rate.positive { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .funding-rate.negative { background: rgba(255, 51, 102, 0.2); color: #ff3366; }

        .trade-row { transition: all 0.3s ease; }
        .trade-row:hover { background: rgba(255, 255, 255, 0.05); }

        .accuracy-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .accuracy-badge.high { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
        .accuracy-badge.medium { background: rgba(255, 149, 0, 0.3); color: #ff9500; }
        .accuracy-badge.low { background: rgba(255, 51, 102, 0.3); color: #ff3366; }

        .status-active { color: var(--neon-blue); }
        .status-won { color: var(--neon-green); }
        .status-lost { color: var(--neon-red); }

        .lock-icon { font-size: 10px; margin-left: 4px; }
    </style>
</head>
<body>
    <div class="cyber-grid"></div>
    
    <!-- Header -->
    <header class="relative z-10 p-4 border-b border-white/10">
        <div class="max-w-7xl mx-auto flex items-center justify-between flex-wrap gap-4">
            <div class="flex items-center gap-4">
                <div class="w-12 h-12 rounded-xl bg-gradient-to-br from-green-400 to-purple-600 flex items-center justify-center">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                    </svg>
                </div>
                <div>
                    <h1 class="title-font text-2xl font-bold bg-gradient-to-r from-green-400 via-purple-400 to-blue-400 bg-clip-text text-transparent">
                        CRYPTOORACLE PRO
                    </h1>
                    <p class="text-xs text-gray-400">Bybit Real-Time â€¢ $100 Investment Tracker</p>
                </div>
            </div>
            
            <div class="flex items-center gap-4 flex-wrap">
                <div id="wsStatus" class="connection-status connecting">
                    <div class="w-2 h-2 rounded-full bg-orange-400 animate-pulse"></div>
                    <span>Connecting...</span>
                </div>

                <div class="glass-panel px-4 py-2 flex items-center gap-3">
                    <div class="pulse-dot w-2 h-2 rounded-full bg-green-400"></div>
                    <span class="text-sm text-gray-300">LIVE</span>
                    <span id="currentTime" class="title-font text-green-400">--:--:--</span>
                </div>
                
                <div class="glass-panel px-4 py-2">
                    <div class="text-xs text-gray-400">Win Rate</div>
                    <div id="accuracy24h" class="title-font text-xl text-green-400">--%</div>
                </div>
                
                <div class="glass-panel px-4 py-2">
                    <div class="text-xs text-gray-400">Total Trades</div>
                    <div id="totalTrades" class="title-font text-xl text-purple-400">0</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Crypto Tabs -->
    <nav class="relative z-10 p-4">
        <div class="max-w-7xl mx-auto flex gap-3 overflow-x-auto pb-2" id="cryptoTabs"></div>
    </nav>

    <!-- Main Dashboard -->
    <main class="relative z-10 p-4 max-w-7xl mx-auto">
        <!-- Top Row -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-4 mb-4">
            <!-- CPS Gauge -->
            <div class="glass-panel p-6 neon-glow-purple col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">COMPOSITE PREDICTIVE SCORE</h3>
                <div class="flex flex-col items-center">
                    <div class="gauge-container mb-4">
                        <svg class="gauge-bg" viewBox="0 0 200 120">
                            <defs>
                                <linearGradient id="gaugeGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#ff3366"/>
                                    <stop offset="50%" style="stop-color:#9945ff"/>
                                    <stop offset="100%" style="stop-color:#00ff88"/>
                                </linearGradient>
                            </defs>
                            <path d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="url(#gaugeGrad)" stroke-width="12" stroke-linecap="round"/>
                            <path d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="20" stroke-linecap="round"/>
                        </svg>
                        <div id="gaugeNeedle" class="gauge-needle" style="transform: rotate(-90deg);"></div>
                        <div class="absolute bottom-0 left-0 right-0 text-center">
                            <div id="cpsValue" class="title-font text-4xl font-bold">--</div>
                            <div id="cpsLabel" class="text-sm text-gray-400">CALCULATING...</div>
                        </div>
                    </div>
                    <div class="flex justify-between w-full text-xs text-gray-500">
                        <span>STRONG SELL</span>
                        <span>NEUTRAL</span>
                        <span>STRONG BUY</span>
                    </div>
                </div>
            </div>

            <!-- Live Price Panel -->
            <div class="glass-panel p-6 col-span-1">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="title-font text-sm text-gray-400">LIVE PRICE</h3>
                    <span id="fundingRate" class="funding-rate">Funding: --%</span>
                </div>
                <div id="livePrice" class="title-font text-4xl font-bold text-white mb-2">$--,---</div>
                <div class="flex items-center gap-2">
                    <span id="priceChange" class="text-lg">--%</span>
                    <span class="text-xs text-gray-500">24H</span>
                </div>
                <div class="mt-4 grid grid-cols-2 gap-2 text-xs">
                    <div>
                        <div class="text-gray-500">24H High</div>
                        <div id="high24h" class="text-green-400">$--</div>
                    </div>
                    <div>
                        <div class="text-gray-500">24H Low</div>
                        <div id="low24h" class="text-red-400">$--</div>
                    </div>
                    <div>
                        <div class="text-gray-500">24H Volume</div>
                        <div id="volume24h" class="text-purple-400">$--</div>
                    </div>
                    <div>
                        <div class="text-gray-500">Open Interest</div>
                        <div id="openInterest" class="text-blue-400">$--</div>
                    </div>
                </div>
            </div>

            <!-- Countdown Timer -->
            <div class="glass-panel p-6 col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">NEXT PREDICTION</h3>
                <div class="flex items-center justify-center mb-4">
                    <div class="relative">
                        <svg class="w-24 h-24 transform -rotate-90">
                            <circle cx="48" cy="48" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="6"/>
                            <circle id="countdownRing" class="countdown-ring" cx="48" cy="48" r="45" fill="none" stroke="url(#gaugeGrad)" stroke-width="6" stroke-linecap="round"/>
                        </svg>
                        <div class="absolute inset-0 flex items-center justify-center">
                            <span id="countdownText" class="title-font text-2xl">--:--</span>
                        </div>
                    </div>
                </div>
                <div class="text-center">
                    <div id="activeInterval" class="text-sm text-purple-400">1 MIN INTERVAL</div>
                    <div class="text-xs text-gray-500 mt-1">Predictions locked until expiry</div>
                </div>
            </div>

            <!-- Fear & Greed Index -->
            <div class="glass-panel p-6 col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">FEAR & GREED INDEX</h3>
                <div class="flex items-center justify-center">
                    <div class="relative w-32 h-32">
                        <svg viewBox="0 0 100 100" class="w-full h-full">
                            <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="8"/>
                            <circle id="fgCircle" cx="50" cy="50" r="45" fill="none" stroke="var(--neon-orange)" stroke-width="8" stroke-linecap="round" stroke-dasharray="283" stroke-dashoffset="141" transform="rotate(-90 50 50)"/>
                        </svg>
                        <div class="absolute inset-0 flex flex-col items-center justify-center">
                            <span id="fgValue" class="title-font text-3xl font-bold">--</span>
                            <span id="fgLabel" class="text-xs text-gray-400">LOADING</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Prediction Cards Row -->
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-7 gap-3 mb-4" id="predictionCards"></div>

        <!-- Main Chart Area -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-4">
            <!-- Price Chart -->
            <div class="glass-panel p-6 col-span-2 relative overflow-hidden">
                <div class="scan-line"></div>
                <div class="flex items-center justify-between mb-4">
                    <h3 class="title-font text-sm text-gray-400">PRICE CHART & PREDICTIONS</h3>
                    <div class="flex gap-2">
                        <button onclick="setChartRange('1h')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/10 hover:bg-white/20">1H</button>
                        <button onclick="setChartRange('4h')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/10 hover:bg-white/20">4H</button>
                        <button onclick="setChartRange('1d')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/20 border border-purple-500">1D</button>
                    </div>
                </div>
                <div class="h-80">
                    <canvas id="priceChart"></canvas>
                </div>
                <div class="flex items-center gap-6 mt-4 text-xs">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-blue-400"></div>
                        <span>Actual Price</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-green-400"></div>
                        <span>Predicted Target</span>
                    </div>
                </div>
            </div>

            <!-- Parameters Heatmap -->
            <div class="glass-panel p-6 col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">SIGNAL INDICATORS</h3>
                <div id="paramHeatmap" class="grid grid-cols-2 gap-2"></div>
            </div>
        </div>

        <!-- Trade History -->
        <div class="glass-panel p-6 mb-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="title-font text-sm text-gray-400">TRADE HISTORY ($100 Investment)</h3>
                <div class="flex items-center gap-4">
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">Total P/L:</span>
                        <span id="totalPL" class="title-font text-green-400">+$0.00</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">Avg Accuracy:</span>
                        <span id="avgAccuracy" class="title-font text-purple-400">--%</span>
                    </div>
                </div>
            </div>
            
            <!-- Table Header -->
            <div class="grid grid-cols-12 gap-2 text-xs text-gray-500 pb-2 border-b border-white/10 mb-2">
                <div class="col-span-1">Time</div>
                <div class="col-span-1">Pair</div>
                <div class="col-span-1">Direction</div>
                <div class="col-span-1">Interval</div>
                <div class="col-span-2">Entry â†’ Exit</div>
                <div class="col-span-2">Predicted â†’ Actual</div>
                <div class="col-span-1">Accuracy</div>
                <div class="col-span-1">P/L ($100)</div>
                <div class="col-span-1">Status</div>
            </div>
            
            <div class="overflow-y-auto max-h-64" id="tradeHistory">
                <div class="text-center text-gray-500 py-8">Waiting for first prediction to complete...</div>
            </div>
        </div>

        <!-- Stats Grid -->
        <div class="grid grid-cols-2 md:grid-cols-6 gap-3">
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Winning Trades</div>
                <div id="winningTrades" class="title-font text-2xl text-green-400">0</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Losing Trades</div>
                <div id="losingTrades" class="title-font text-2xl text-red-400">0</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Avg Win</div>
                <div id="avgProfit" class="title-font text-2xl text-green-400">+$0</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Avg Loss</div>
                <div id="avgLoss" class="title-font text-2xl text-red-400">-$0</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Best Trade</div>
                <div id="bestTrade" class="title-font text-2xl text-green-400">+$0</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Worst Trade</div>
                <div id="worstTrade" class="title-font text-2xl text-red-400">-$0</div>
            </div>
        </div>
    </main>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center">
        <div class="text-center">
            <div class="w-16 h-16 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
            <div class="title-font text-xl text-white mb-2">INITIALIZING ORACLE</div>
            <div id="loadingStatus" class="text-sm text-gray-400">Connecting to Bybit...</div>
            <div class="w-64 h-1 bg-gray-800 rounded-full mt-4 overflow-hidden">
                <div class="loading-bar h-full rounded-full"></div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // CRYPTOORACLE PRO - FIXED VERSION
        // Only real data, static predictions, proper P/L tracking
        // ==========================================

        const CONFIG = {
            cryptos: [
                { id: 'BTCUSDT', symbol: 'BTC', name: 'Bitcoin', color: '#f7931a' },
                { id: 'ETHUSDT', symbol: 'ETH', name: 'Ethereum', color: '#627eea' },
                { id: 'SOLUSDT', symbol: 'SOL', name: 'Solana', color: '#00ffa3' },
                { id: 'BNBUSDT', symbol: 'BNB', name: 'BNB', color: '#f3ba2f' },
                { id: 'XRPUSDT', symbol: 'XRP', name: 'XRP', color: '#00aae4' }
            ],
            intervals: [
                { label: '1 MIN', seconds: 60, key: '1m', bybit: '1' },
                { label: '5 MIN', seconds: 300, key: '5m', bybit: '5' },
                { label: '15 MIN', seconds: 900, key: '15m', bybit: '15' },
                { label: '1 HOUR', seconds: 3600, key: '1h', bybit: '60' },
                { label: '4 HOURS', seconds: 14400, key: '4h', bybit: '240' },
                { label: '1 DAY', seconds: 86400, key: '1d', bybit: 'D' },
                { label: '1 WEEK', seconds: 604800, key: '1w', bybit: 'W' }
            ],
            investment: 100,
            bybitRestUrl: 'https://api.bybit.com',
            bybitWsUrl: 'wss://stream.bybit.com/v5/public/linear'
        };

        // State
        const state = {
            currentCrypto: 'BTCUSDT',
            currentInterval: 0,
            currentChartRange: '1d',
            
            // Real-time prices from WebSocket
            livePrices: {},
            
            // Historical klines
            klines: {},
            
            // Locked predictions (immutable until expiry)
            predictions: {},
            
            // Calculated parameters
            parameters: {},
            
            // Completed trades history
            tradeHistory: [],
            
            // Statistics
            stats: {
                totalTrades: 0,
                winningTrades: 0,
                losingTrades: 0,
                totalPL: 0,
                totalAccuracy: 0
            },
            
            // Fear & Greed
            fearGreed: { value: 50, classification: 'Neutral' },
            
            // Countdown
            countdownSeconds: 60,
            
            // Charts
            charts: {},
            
            // WebSocket
            ws: null,
            wsConnected: false,
            wsReconnectAttempts: 0
        };

        // ==========================================
        // BYBIT API - ONLY REAL DATA
        // ==========================================

        async function fetchBybitTicker(symbol) {
            const response = await fetch(`${CONFIG.bybitRestUrl}/v5/market/tickers?category=linear&symbol=${symbol}`);
            const data = await response.json();
            
            if (data.retCode !== 0 || !data.result.list.length) {
                throw new Error(`Failed to fetch ticker for ${symbol}`);
            }
            
            const ticker = data.result.list[0];
            return {
                symbol: symbol,
                price: parseFloat(ticker.lastPrice),
                change24h: parseFloat(ticker.price24hPcnt) * 100,
                high24h: parseFloat(ticker.highPrice24h),
                low24h: parseFloat(ticker.lowPrice24h),
                volume24h: parseFloat(ticker.turnover24h),
                fundingRate: parseFloat(ticker.fundingRate) * 100,
                bid: parseFloat(ticker.bid1Price),
                ask: parseFloat(ticker.ask1Price),
                timestamp: Date.now()
            };
        }

        async function fetchBybitKlines(symbol, interval = '60', limit = 100) {
            const response = await fetch(
                `${CONFIG.bybitRestUrl}/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${limit}`
            );
            const data = await response.json();
            
            if (data.retCode !== 0) {
                throw new Error(`Failed to fetch klines for ${symbol}`);
            }
            
            return data.result.list.reverse().map(k => ({
                timestamp: parseInt(k[0]),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            }));
        }

        async function fetchBybitOrderbook(symbol) {
            const response = await fetch(
                `${CONFIG.bybitRestUrl}/v5/market/orderbook?category=linear&symbol=${symbol}&limit=25`
            );
            const data = await response.json();
            
            if (data.retCode !== 0) {
                return { imbalance: 0 };
            }
            
            const bids = data.result.b.reduce((sum, b) => sum + parseFloat(b[1]), 0);
            const asks = data.result.a.reduce((sum, a) => sum + parseFloat(a[1]), 0);
            
            return {
                bidTotal: bids,
                askTotal: asks,
                imbalance: bids + asks > 0 ? (bids - asks) / (bids + asks) : 0
            };
        }

        async function fetchBybitOpenInterest(symbol) {
            const response = await fetch(
                `${CONFIG.bybitRestUrl}/v5/market/open-interest?category=linear&symbol=${symbol}&intervalTime=1h&limit=1`
            );
            const data = await response.json();
            
            if (data.retCode !== 0 || !data.result.list.length) {
                return 0;
            }
            
            return parseFloat(data.result.list[0].openInterest);
        }

        async function fetchFearGreedIndex() {
            try {
                const response = await fetch('https://api.alternative.me/fng/?limit=1');
                const data = await response.json();
                
                if (data?.data?.length) {
                    return {
                        value: parseInt(data.data[0].value),
                        classification: data.data[0].value_classification
                    };
                }
            } catch (e) {
                console.warn('Fear & Greed fetch failed:', e);
            }
            return { value: 50, classification: 'Neutral' };
        }

        // ==========================================
        // WEBSOCKET - REAL-TIME PRICES ONLY
        // ==========================================

        function initWebSocket() {
            if (state.ws) {
                state.ws.close();
            }
            
            updateWSStatus('connecting');
            state.ws = new WebSocket(CONFIG.bybitWsUrl);
            
            state.ws.onopen = () => {
                console.log('âœ… WebSocket connected to Bybit');
                state.wsConnected = true;
                state.wsReconnectAttempts = 0;
                updateWSStatus('connected');
                
                // Subscribe to all tickers
                const args = CONFIG.cryptos.map(c => `tickers.${c.id}`);
                state.ws.send(JSON.stringify({ op: 'subscribe', args }));
            };
            
            state.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.topic?.startsWith('tickers.')) {
                        handleTickerUpdate(data);
                    }
                } catch (e) {
                    console.error('WS parse error:', e);
                }
            };
            
            state.ws.onclose = () => {
                console.log('âŒ WebSocket disconnected');
                state.wsConnected = false;
                updateWSStatus('disconnected');
                
                // Reconnect with exponential backoff
                const delay = Math.min(30000, 1000 * Math.pow(2, state.wsReconnectAttempts));
                state.wsReconnectAttempts++;
                console.log(`Reconnecting in ${delay}ms...`);
                setTimeout(initWebSocket, delay);
            };
            
            state.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        function handleTickerUpdate(data) {
            const symbol = data.topic.replace('tickers.', '');
            const ticker = data.data;
            
            // Update live price
            state.livePrices[symbol] = {
                price: parseFloat(ticker.lastPrice),
                change24h: parseFloat(ticker.price24hPcnt) * 100,
                high24h: parseFloat(ticker.highPrice24h),
                low24h: parseFloat(ticker.lowPrice24h),
                volume24h: parseFloat(ticker.turnover24h),
                fundingRate: parseFloat(ticker.fundingRate) * 100,
                timestamp: Date.now()
            };
            
            // Update UI
            if (symbol === state.currentCrypto) {
                updateLivePriceUI();
            }
            updateTabPrices();
            
            // Check if any predictions expired
            checkExpiredPredictions();
        }

        function updateWSStatus(status) {
            const el = document.getElementById('wsStatus');
            if (!el) return;
            
            const configs = {
                connected: { class: 'connected', html: '<div class="w-2 h-2 rounded-full bg-green-400"></div><span>Live</span>' },
                disconnected: { class: 'disconnected', html: '<div class="w-2 h-2 rounded-full bg-red-400"></div><span>Offline</span>' },
                connecting: { class: 'connecting', html: '<div class="w-2 h-2 rounded-full bg-orange-400 animate-pulse"></div><span>Connecting...</span>' }
            };
            
            const cfg = configs[status] || configs.connecting;
            el.className = `connection-status ${cfg.class}`;
            el.innerHTML = cfg.html;
        }

        // ==========================================
        // TECHNICAL INDICATORS
        // ==========================================

        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0, losses = 0;
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            if (avgLoss === 0) return 100;
            
            return 100 - (100 / (1 + avgGain / avgLoss));
        }

        function calculateMACD(prices) {
            if (prices.length < 26) return { value: 0, signal: 0, histogram: 0 };
            
            const ema = (data, period) => {
                const k = 2 / (period + 1);
                let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
                for (let i = period; i < data.length; i++) {
                    ema = data[i] * k + ema * (1 - k);
                }
                return ema;
            };
            
            const ema12 = ema(prices, 12);
            const ema26 = ema(prices, 26);
            const macd = ema12 - ema26;
            
            return { value: macd, signal: macd * 0.9, histogram: macd * 0.1 };
        }

        function calculateBollingerBands(prices, period = 20) {
            if (prices.length < period) return { percentB: 0.5 };
            
            const recent = prices.slice(-period);
            const sma = recent.reduce((a, b) => a + b, 0) / period;
            const std = Math.sqrt(recent.reduce((sum, p) => sum + Math.pow(p - sma, 2), 0) / period);
            
            const upper = sma + 2 * std;
            const lower = sma - 2 * std;
            const current = prices[prices.length - 1];
            const percentB = std > 0 ? (current - lower) / (upper - lower) : 0.5;
            
            return { upper, middle: sma, lower, percentB: Math.max(0, Math.min(1, percentB)) };
        }

        function calculateMomentum(prices, period = 10) {
            if (prices.length < period + 1) return 0;
            const current = prices[prices.length - 1];
            const past = prices[prices.length - period - 1];
            return ((current - past) / past) * 100;
        }

        function calculateVolumeProfile(klines) {
            if (klines.length < 10) return 0;
            const recent = klines.slice(-10);
            const avgVol = recent.slice(0, -1).reduce((sum, k) => sum + k.volume, 0) / 9;
            const lastVol = recent[recent.length - 1].volume;
            return avgVol > 0 ? (lastVol - avgVol) / avgVol : 0;
        }

        async function calculateAllParameters(symbol) {
            const klines = state.klines[symbol];
            if (!klines || klines.length < 30) return null;
            
            const prices = klines.map(k => k.close);
            const liveData = state.livePrices[symbol];
            
            // Technical indicators
            const rsi = calculateRSI(prices);
            const macd = calculateMACD(prices);
            const bb = calculateBollingerBands(prices);
            const momentum = calculateMomentum(prices);
            const volumeProfile = calculateVolumeProfile(klines);
            
            // Market data
            const orderbook = await fetchBybitOrderbook(symbol);
            const openInterest = await fetchBybitOpenInterest(symbol);
            
            // Normalize to -1 to 1
            const params = {
                rsi: (50 - rsi) / 50, // Inverted: low RSI = bullish
                macd: Math.max(-1, Math.min(1, macd.histogram / (liveData?.price || 1) * 1000)),
                bollinger: (0.5 - bb.percentB) * 2, // Inverted: low %B = bullish
                momentum: Math.max(-1, Math.min(1, momentum / 5)),
                volume: Math.max(-1, Math.min(1, volumeProfile)),
                orderbook: orderbook.imbalance,
                funding: liveData?.fundingRate ? -Math.max(-1, Math.min(1, liveData.fundingRate * 10)) : 0,
                fearGreed: (50 - state.fearGreed.value) / 50
            };
            
            state.parameters[symbol] = params;
            state.openInterest = openInterest * (liveData?.price || 0);
            
            return params;
        }

        // ==========================================
        // COMPOSITE PREDICTIVE SCORE
        // ==========================================

        function calculateCPS(params) {
            if (!params) return 0;
            
            const weights = {
                rsi: 0.15,
                macd: 0.12,
                bollinger: 0.10,
                momentum: 0.13,
                volume: 0.10,
                orderbook: 0.12,
                funding: 0.15,
                fearGreed: 0.13
            };
            
            let cps = 0;
            for (const [key, weight] of Object.entries(weights)) {
                cps += (params[key] || 0) * weight;
            }
            
            return Math.max(-1, Math.min(1, cps));
        }

        function getCPSLabel(cps) {
            if (cps >= 0.5) return { label: 'STRONG BUY', color: '#00ff88', direction: 'LONG' };
            if (cps >= 0.15) return { label: 'BUY', color: '#00dd66', direction: 'LONG' };
            if (cps >= -0.15) return { label: 'NEUTRAL', color: '#9945ff', direction: 'HOLD' };
            if (cps >= -0.5) return { label: 'SELL', color: '#ff6644', direction: 'SHORT' };
            return { label: 'STRONG SELL', color: '#ff3366', direction: 'SHORT' };
        }

        // ==========================================
        // PREDICTION ENGINE - LOCKED PREDICTIONS
        // ==========================================

        function createPrediction(symbol, interval, params) {
            const liveData = state.livePrices[symbol];
            if (!liveData) return null;
            
            const cps = calculateCPS(params);
            const cpsInfo = getCPSLabel(cps);
            
            if (cpsInfo.direction === 'HOLD') {
                // Ð”Ð»Ñ NEUTRAL Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÑÐ»Ð°Ð±Ñ‹Ð¹ LONG
                cpsInfo.direction = 'LONG';
            }
            
            // Calculate predicted price
            const volatilityBase = 0.01; // 1% base volatility
            const timeMultiplier = Math.sqrt(interval.seconds / 60);
            const magnitude = Math.abs(cps);
            const direction = cpsInfo.direction === 'LONG' ? 1 : -1;
            
            const expectedMove = liveData.price * volatilityBase * timeMultiplier * magnitude * direction;
            const predictedPrice = liveData.price + expectedMove;
            
            const prediction = {
                id: `${symbol}-${interval.key}-${Date.now()}`,
                symbol: symbol,
                interval: interval.key,
                intervalLabel: interval.label,
                
                // Entry data (LOCKED)
                entryPrice: liveData.price,
                entryTime: Date.now(),
                
                // Prediction (LOCKED)
                predictedPrice: predictedPrice,
                direction: cpsInfo.direction,
                cps: cps,
                confidence: Math.round((0.5 + magnitude * 0.4) * 100),
                
                // Parameters snapshot
                parameters: { ...params },
                
                // Timing
                expiresAt: Date.now() + (interval.seconds * 1000),
                
                // Status
                status: 'ACTIVE',
                
                // Results (filled on expiry)
                exitPrice: null,
                exitTime: null,
                actualPL: null,
                accuracy: null
            };
            
            return prediction;
        }

        function generatePredictions(symbol) {
            const params = state.parameters[symbol];
            if (!params) return;
            
            if (!state.predictions[symbol]) {
                state.predictions[symbol] = {};
            }
            
            CONFIG.intervals.forEach(interval => {
                const existing = state.predictions[symbol][interval.key];
                
                // Only create new prediction if none exists or previous expired
                if (!existing || existing.status !== 'ACTIVE') {
                    const prediction = createPrediction(symbol, interval, params);
                    if (prediction) {
                        state.predictions[symbol][interval.key] = prediction;
                        console.log(`ðŸ“Š New ${interval.label} prediction for ${symbol}: ${prediction.direction} @ ${prediction.predictedPrice.toFixed(2)}`);
                    }
                }
            });
        }

        // ==========================================
        // PREDICTION EVALUATION
        // ==========================================

        function checkExpiredPredictions() {
            const now = Date.now();
            
            Object.keys(state.predictions).forEach(symbol => {
                Object.keys(state.predictions[symbol]).forEach(intervalKey => {
                    const pred = state.predictions[symbol][intervalKey];
                    
                    if (pred.status === 'ACTIVE' && now >= pred.expiresAt) {
                        evaluatePrediction(pred);
                    }
                });
            });
        }

        function evaluatePrediction(prediction) {
            const liveData = state.livePrices[prediction.symbol];
            if (!liveData) return;
            
            const exitPrice = liveData.price;
            const entryPrice = prediction.entryPrice;
            const predictedPrice = prediction.predictedPrice;
            
            // Calculate actual price change
            const actualChange = (exitPrice - entryPrice) / entryPrice;
            
            // Calculate P/L based on direction
            let pl;
            if (prediction.direction === 'LONG') {
                pl = actualChange * CONFIG.investment;
            } else { // SHORT
                pl = -actualChange * CONFIG.investment;
            }
            
            // Calculate prediction accuracy
            const predictedChange = (predictedPrice - entryPrice) / entryPrice;
            const actualDirection = actualChange > 0 ? 'LONG' : 'SHORT';
            const directionCorrect = prediction.direction === actualDirection;
            
            // Accuracy: how close was prediction to actual
            const priceAccuracy = Math.max(0, 100 - Math.abs((exitPrice - predictedPrice) / entryPrice * 100) * 10);
            const accuracy = directionCorrect ? Math.min(100, priceAccuracy + 20) : Math.max(0, priceAccuracy - 30);
            
            // Update prediction
            prediction.exitPrice = exitPrice;
            prediction.exitTime = Date.now();
            prediction.actualPL = pl;
            prediction.accuracy = accuracy;
            prediction.status = pl > 0 ? 'WON' : 'LOST';
            
            // Add to trade history
            state.tradeHistory.unshift({ ...prediction });
            if (state.tradeHistory.length > 100) {
                state.tradeHistory.pop();
            }
            
            // Update stats
            state.stats.totalTrades++;
            if (pl > 0) {
                state.stats.winningTrades++;
            } else {
                state.stats.losingTrades++;
            }
            state.stats.totalPL += pl;
            state.stats.totalAccuracy = state.tradeHistory.reduce((sum, t) => sum + (t.accuracy || 0), 0) / state.tradeHistory.length;
            
            console.log(`âœ… Trade completed: ${prediction.symbol} ${prediction.direction} | P/L: $${pl.toFixed(2)} | Accuracy: ${accuracy.toFixed(1)}%`);
            
            // Update UI
            updateTradeHistoryUI();
            updateStatsUI();
            
            // Create new prediction for this interval
            const interval = CONFIG.intervals.find(i => i.key === prediction.interval);
            if (interval) {
                const params = state.parameters[prediction.symbol];
                if (params) {
                    const newPred = createPrediction(prediction.symbol, interval, params);
                    if (newPred) {
                        state.predictions[prediction.symbol][prediction.interval] = newPred;
                    }
                }
            }
        }

        // ==========================================
        // UI RENDERING
        // ==========================================

        function renderCryptoTabs() {
            const container = document.getElementById('cryptoTabs');
            container.innerHTML = CONFIG.cryptos.map(crypto => `
                <div class="crypto-tab glass-panel px-4 py-3 flex items-center gap-3 ${crypto.id === state.currentCrypto ? 'active' : ''}"
                     onclick="selectCrypto('${crypto.id}')" style="border-color: ${crypto.color}20">
                    <div class="w-8 h-8 rounded-full flex items-center justify-center" style="background: ${crypto.color}30">
                        <span class="title-font font-bold" style="color: ${crypto.color}">${crypto.symbol.charAt(0)}</span>
                    </div>
                    <div>
                        <div class="font-semibold">${crypto.symbol}</div>
                        <div class="text-xs text-gray-500">${crypto.name}</div>
                    </div>
                    <div class="ml-auto text-right">
                        <div id="tab-price-${crypto.id}" class="font-mono text-sm">Loading...</div>
                        <div id="tab-change-${crypto.id}" class="text-xs text-gray-400">--%</div>
                    </div>
                </div>
            `).join('');
        }

        function renderPredictionCards() {
            const container = document.getElementById('predictionCards');
            const symbol = state.currentCrypto;
            const predictions = state.predictions[symbol] || {};
            
            container.innerHTML = CONFIG.intervals.map((interval, idx) => {
                const pred = predictions[interval.key];
                const isActive = pred && pred.status === 'ACTIVE';
                const timeLeft = pred ? Math.max(0, pred.expiresAt - Date.now()) : 0;
                const progress = pred ? ((Date.now() - pred.entryTime) / (pred.expiresAt - pred.entryTime)) * 100 : 0;
                
                return `
                    <div class="prediction-card glass-panel p-4 cursor-pointer ${idx === state.currentInterval ? 'neon-glow-purple' : ''} ${isActive ? 'locked' : ''}"
                         onclick="selectInterval(${idx})">
                        <div class="flex items-center justify-between mb-2">
                            <span class="title-font text-xs text-gray-400">${interval.label}</span>
                            ${isActive ? '<span class="lock-icon">ðŸ”’</span>' : ''}
                        </div>
                        <div class="title-font text-lg font-bold text-white">
                            ${pred ? formatPrice(pred.predictedPrice) : '$--'}
                        </div>
                        <div class="text-xs mb-2 ${pred?.direction === 'LONG' ? 'text-green-400' : pred?.direction === 'SHORT' ? 'text-red-400' : 'text-gray-400'}">
                            ${pred ? `${pred.direction} (${pred.confidence}%)` : '--'}
                        </div>
                        <div class="text-xs text-gray-500 mb-2">
                            ${isActive ? `Expires: ${formatTimeLeft(timeLeft)}` : 'Waiting...'}
                        </div>
                        <div class="h-1 bg-gray-800 rounded-full overflow-hidden">
                            <div class="h-full ${isActive ? 'bg-purple-500' : 'bg-gray-600'} transition-all" 
                                 style="width: ${Math.min(100, progress)}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderParameterHeatmap(params) {
            if (!params) return;
            
            const paramInfo = {
                rsi: { name: 'RSI', icon: 'ðŸ“Š' },
                macd: { name: 'MACD', icon: 'ðŸ“ˆ' },
                bollinger: { name: 'Bollinger', icon: 'ðŸ“‰' },
                momentum: { name: 'Momentum', icon: 'ðŸš€' },
                volume: { name: 'Volume', icon: 'ðŸ“Š' },
                orderbook: { name: 'Orders', icon: 'ðŸ“•' },
                funding: { name: 'Funding', icon: 'ðŸ’°' },
                fearGreed: { name: 'F&G', icon: 'ðŸ˜±' }
            };

            const container = document.getElementById('paramHeatmap');
            container.innerHTML = Object.entries(params).map(([key, value]) => {
                const info = paramInfo[key] || { name: key, icon: 'â“' };
                const isPositive = value > 0;
                const colorClass = isPositive ? 'bullish' : value < 0 ? 'bearish' : 'neutral';
                
                return `
                    <div class="param-block glass-panel p-3 ${colorClass}">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-lg">${info.icon}</span>
                            <span class="text-xs font-mono ${isPositive ? 'text-green-400' : 'text-red-400'}">
                                ${value >= 0 ? '+' : ''}${(value * 100).toFixed(0)}%
                            </span>
                        </div>
                        <div class="text-xs text-gray-400">${info.name}</div>
                    </div>
                `;
            }).join('');
        }

        function updateLivePriceUI() {
            const data = state.livePrices[state.currentCrypto];
            if (!data) return;
            
            document.getElementById('livePrice').textContent = formatPrice(data.price);
            
            const changeEl = document.getElementById('priceChange');
            changeEl.textContent = `${data.change24h >= 0 ? '+' : ''}${data.change24h.toFixed(2)}%`;
            changeEl.className = `text-lg ${data.change24h >= 0 ? 'text-green-400' : 'text-red-400'}`;
            
            document.getElementById('high24h').textContent = formatPrice(data.high24h);
            document.getElementById('low24h').textContent = formatPrice(data.low24h);
            document.getElementById('volume24h').textContent = formatVolume(data.volume24h);
            
            const fundingEl = document.getElementById('fundingRate');
            fundingEl.textContent = `Funding: ${data.fundingRate >= 0 ? '+' : ''}${data.fundingRate.toFixed(4)}%`;
            fundingEl.className = `funding-rate ${data.fundingRate >= 0 ? 'positive' : 'negative'}`;
            
            if (state.openInterest) {
                document.getElementById('openInterest').textContent = formatVolume(state.openInterest);
            }
            
            // Update CPS gauge
            const params = state.parameters[state.currentCrypto];
            if (params) {
                const cps = calculateCPS(params);
                const cpsInfo = getCPSLabel(cps);
                
                const angle = -90 + (cps + 1) * 90;
                document.getElementById('gaugeNeedle').style.transform = `rotate(${angle}deg)`;
                document.getElementById('cpsValue').textContent = (cps * 100).toFixed(0);
                document.getElementById('cpsValue').style.color = cpsInfo.color;
                document.getElementById('cpsLabel').textContent = cpsInfo.label;
                document.getElementById('cpsLabel').style.color = cpsInfo.color;
            }
            
            // Update prediction cards (to show current P/L)
            updatePredictionCurrentPL();
        }

        function updatePredictionCurrentPL() {
            const symbol = state.currentCrypto;
            const predictions = state.predictions[symbol];
            const liveData = state.livePrices[symbol];
            
            if (!predictions || !liveData) return;
            
            // Cards are re-rendered less frequently, but we can update time left here
            renderPredictionCards();
        }

        function updateTabPrices() {
            CONFIG.cryptos.forEach(crypto => {
                const data = state.livePrices[crypto.id];
                if (!data) return;
                
                const priceEl = document.getElementById(`tab-price-${crypto.id}`);
                const changeEl = document.getElementById(`tab-change-${crypto.id}`);
                
                if (priceEl) priceEl.textContent = formatPrice(data.price);
                if (changeEl) {
                    changeEl.textContent = `${data.change24h >= 0 ? '+' : ''}${data.change24h.toFixed(2)}%`;
                    changeEl.className = `text-xs ${data.change24h >= 0 ? 'text-green-400' : 'text-red-400'}`;
                }
            });
        }

        function updateTradeHistoryUI() {
            const container = document.getElementById('tradeHistory');
            const trades = state.tradeHistory.slice(0, 20);
            
            if (trades.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-500 py-8">Waiting for first prediction to complete...</div>';
                return;
            }

            container.innerHTML = trades.map(trade => {
                const crypto = CONFIG.cryptos.find(c => c.id === trade.symbol);
                const isWin = trade.actualPL > 0;
                const accuracyClass = trade.accuracy >= 70 ? 'high' : trade.accuracy >= 40 ? 'medium' : 'low';
                
                return `
                    <div class="trade-row grid grid-cols-12 gap-2 text-xs py-2 border-b border-white/5 items-center">
                        <div class="col-span-1 text-gray-400">
                            ${new Date(trade.entryTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                        </div>
                        <div class="col-span-1 font-semibold" style="color: ${crypto?.color || '#fff'}">
                            ${crypto?.symbol || trade.symbol}
                        </div>
                        <div class="col-span-1">
                            <span class="px-2 py-0.5 rounded text-xs ${trade.direction === 'LONG' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}">
                                ${trade.direction}
                            </span>
                        </div>
                        <div class="col-span-1 text-gray-400">${trade.intervalLabel}</div>
                        <div class="col-span-2 font-mono">
                            ${formatPrice(trade.entryPrice)} â†’ ${formatPrice(trade.exitPrice)}
                        </div>
                        <div class="col-span-2 font-mono text-gray-400">
                            ${formatPrice(trade.predictedPrice)} â†’ ${formatPrice(trade.exitPrice)}
                        </div>
                        <div class="col-span-1">
                            <span class="accuracy-badge ${accuracyClass}">${trade.accuracy?.toFixed(0) || 0}%</span>
                        </div>
                        <div class="col-span-1 font-mono font-bold ${isWin ? 'text-green-400' : 'text-red-400'}">
                            ${isWin ? '+' : ''}$${trade.actualPL?.toFixed(2) || '0.00'}
                        </div>
                        <div class="col-span-1 status-${trade.status?.toLowerCase() || 'active'}">
                            ${trade.status || 'ACTIVE'}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateStatsUI() {
            const stats = state.stats;
            const trades = state.tradeHistory;
            
            document.getElementById('totalTrades').textContent = stats.totalTrades;
            document.getElementById('winningTrades').textContent = stats.winningTrades;
            document.getElementById('losingTrades').textContent = stats.losingTrades;
            
            const winRate = stats.totalTrades > 0 ? (stats.winningTrades / stats.totalTrades * 100) : 0;
            document.getElementById('accuracy24h').textContent = `${winRate.toFixed(1)}%`;
            
            const totalPLEl = document.getElementById('totalPL');
            totalPLEl.textContent = `${stats.totalPL >= 0 ? '+' : ''}$${stats.totalPL.toFixed(2)}`;
            totalPLEl.className = `title-font ${stats.totalPL >= 0 ? 'text-green-400' : 'text-red-400'}`;
            
            document.getElementById('avgAccuracy').textContent = `${(stats.totalAccuracy || 0).toFixed(1)}%`;
            
            // Calculate averages
            const winningTrades = trades.filter(t => t.actualPL > 0);
            const losingTrades = trades.filter(t => t.actualPL < 0);
            
            const avgProfit = winningTrades.length > 0 ? 
                winningTrades.reduce((sum, t) => sum + t.actualPL, 0) / winningTrades.length : 0;
            const avgLoss = losingTrades.length > 0 ? 
                Math.abs(losingTrades.reduce((sum, t) => sum + t.actualPL, 0)) / losingTrades.length : 0;
            
            document.getElementById('avgProfit').textContent = `+$${avgProfit.toFixed(2)}`;
            document.getElementById('avgLoss').textContent = `-$${avgLoss.toFixed(2)}`;
            
            // Best and worst trades
            if (trades.length > 0) {
                const best = Math.max(...trades.map(t => t.actualPL || 0));
                const worst = Math.min(...trades.map(t => t.actualPL || 0));
                
                document.getElementById('bestTrade').textContent = `+$${Math.max(0, best).toFixed(2)}`;
                document.getElementById('worstTrade').textContent = `-$${Math.abs(Math.min(0, worst)).toFixed(2)}`;
            }
        }

        function updateFearGreedUI() {
            const fg = state.fearGreed;
            document.getElementById('fgValue').textContent = fg.value;
            document.getElementById('fgLabel').textContent = fg.classification.toUpperCase();
            
            const circle = document.getElementById('fgCircle');
            const offset = 283 - (fg.value / 100) * 283;
            circle.style.strokeDashoffset = offset;
            
            const color = fg.value < 25 ? '#ff3366' : 
                         fg.value < 45 ? '#ff6644' :
                         fg.value < 55 ? '#9945ff' :
                         fg.value < 75 ? '#00dd66' : '#00ff88';
            circle.style.stroke = color;
        }

        // ==========================================
        // CHARTS
        // ==========================================

        function initCharts() {
            const priceCtx = document.getElementById('priceChart')?.getContext('2d');
            if (!priceCtx) return;
            
            state.charts.price = new Chart(priceCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Price',
                            data: [],
                            borderColor: '#00d4ff',
                            backgroundColor: 'rgba(0, 212, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'Prediction',
                            data: [],
                            borderColor: '#00ff88',
                            borderDash: [5, 5],
                            pointRadius: 6,
                            pointBackgroundColor: '#00ff88',
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: 'rgba(255,255,255,0.5)', maxTicksLimit: 8 }
                        },
                        y: {
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { 
                                color: 'rgba(255,255,255,0.5)',
                                callback: v => '$' + formatNumber(v)
                            }
                        }
                    }
                }
            });
        }

        function updateCharts() {
            if (!state.charts.price) return;
            
            const klines = state.klines[state.currentCrypto];
            const predictions = state.predictions[state.currentCrypto];
            
            if (!klines || klines.length === 0) return;
            
            const rangeLimits = { '1h': 60, '4h': 48, '1d': 96 };
            const limit = rangeLimits[state.currentChartRange] || 96;
            
            const displayKlines = klines.slice(-limit);
            const labels = displayKlines.map(k => {
                const d = new Date(k.timestamp);
                return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            });
            const prices = displayKlines.map(k => k.close);
            
            // Add prediction points
            const predictionData = new Array(prices.length).fill(null);
            
            if (predictions) {
                const activePred = predictions[CONFIG.intervals[state.currentInterval].key];
                if (activePred && activePred.status === 'ACTIVE') {
                    // Show prediction at the end
                    predictionData[predictionData.length - 1] = activePred.predictedPrice;
                }
            }
            
            state.charts.price.data.labels = labels;
            state.charts.price.data.datasets[0].data = prices;
            state.charts.price.data.datasets[1].data = predictionData;
            state.charts.price.update('none');
        }

        // ==========================================
        // COUNTDOWN
        // ==========================================

        function updateCountdown() {
            state.countdownSeconds--;
            
            if (state.countdownSeconds <= 0) {
                state.countdownSeconds = CONFIG.intervals[state.currentInterval].seconds;
                triggerNewAnalysis();
            }

            const minutes = Math.floor(state.countdownSeconds / 60);
            const seconds = state.countdownSeconds % 60;
            document.getElementById('countdownText').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            const total = CONFIG.intervals[state.currentInterval].seconds;
            const progress = (state.countdownSeconds / total) * 283;
            document.getElementById('countdownRing').style.strokeDashoffset = 283 - progress;
        }

        async function triggerNewAnalysis() {
            console.log('ðŸ”„ Triggering new analysis...');
            
            // Recalculate parameters
            await calculateAllParameters(state.currentCrypto);
            
            // Render updated parameters
            renderParameterHeatmap(state.parameters[state.currentCrypto]);
            
            // Update charts
            updateCharts();
        }

        // ==========================================
        // USER INTERACTIONS
        // ==========================================

        async function selectCrypto(cryptoId) {
            state.currentCrypto = cryptoId;
            renderCryptoTabs();
            
            // Fetch klines if not available
            if (!state.klines[cryptoId] || state.klines[cryptoId].length === 0) {
                try {
                    const interval = CONFIG.intervals[state.currentInterval].bybit;
                    state.klines[cryptoId] = await fetchBybitKlines(cryptoId, interval);
                } catch (e) {
                    console.error('Failed to fetch klines:', e);
                }
            }
            
            // Calculate parameters
            await calculateAllParameters(cryptoId);
            
            // Generate predictions if needed
            generatePredictions(cryptoId);
            
            // Update UI
            updateLivePriceUI();
            renderParameterHeatmap(state.parameters[cryptoId]);
            renderPredictionCards();
            updateCharts();
        }

        async function selectInterval(index) {
            state.currentInterval = index;
            state.countdownSeconds = CONFIG.intervals[index].seconds;
            document.getElementById('activeInterval').textContent = CONFIG.intervals[index].label + ' INTERVAL';
            
            // Fetch new klines
            try {
                const interval = CONFIG.intervals[index].bybit;
                state.klines[state.currentCrypto] = await fetchBybitKlines(state.currentCrypto, interval);
            } catch (e) {
                console.error('Failed to fetch klines:', e);
            }
            
            // Recalculate
            await calculateAllParameters(state.currentCrypto);
            
            renderPredictionCards();
            updateCharts();
        }

        function setChartRange(range) {
            state.currentChartRange = range;
            
            document.querySelectorAll('.chart-range-btn').forEach(btn => {
                btn.classList.remove('border', 'border-purple-500', 'bg-white/20');
                btn.classList.add('bg-white/10');
            });
            
            event.target.classList.add('border', 'border-purple-500', 'bg-white/20');
            event.target.classList.remove('bg-white/10');
            
            updateCharts();
        }

        // ==========================================
        // UTILITIES
        // ==========================================

        function formatPrice(price) {
            if (!price && price !== 0) return '$--';
            if (price >= 1000) return '$' + price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            if (price >= 1) return '$' + price.toFixed(2);
            return '$' + price.toFixed(4);
        }

        function formatVolume(vol) {
            if (!vol && vol !== 0) return '$--';
            if (vol >= 1e12) return '$' + (vol / 1e12).toFixed(2) + 'T';
            if (vol >= 1e9) return '$' + (vol / 1e9).toFixed(2) + 'B';
            if (vol >= 1e6) return '$' + (vol / 1e6).toFixed(2) + 'M';
            if (vol >= 1e3) return '$' + (vol / 1e3).toFixed(2) + 'K';
            return '$' + vol.toFixed(2);
        }

        function formatNumber(num) {
            if (!num && num !== 0) return '--';
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
            return num.toFixed(2);
        }

        function formatTimeLeft(ms) {
            if (ms <= 0) return 'Expired';
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (hours > 0) return `${hours}h ${minutes % 60}m`;
            if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
            return `${seconds}s`;
        }

        function updateCurrentTime() {
            document.getElementById('currentTime').textContent = 
                new Date().toLocaleTimeString('en-US', { hour12: false });
        }

        // ==========================================
        // INITIALIZATION
        // ==========================================

        async function init() {
            console.log('ðŸš€ Initializing CryptoOracle Pro...');
            const loadingStatus = document.getElementById('loadingStatus');
            
            try {
                renderCryptoTabs();
                renderPredictionCards();
                initCharts();
                
                // Fetch initial data for all cryptos
                for (const crypto of CONFIG.cryptos) {
                    loadingStatus.textContent = `Loading ${crypto.name}...`;
                    
                    try {
                        // Fetch ticker
                        const ticker = await fetchBybitTicker(crypto.id);
                        state.livePrices[crypto.id] = ticker;
                        
                        // Fetch klines for current crypto
                        if (crypto.id === state.currentCrypto) {
                            const interval = CONFIG.intervals[state.currentInterval].bybit;
                            state.klines[crypto.id] = await fetchBybitKlines(crypto.id, interval);
                        }
                    } catch (e) {
                        console.error(`Failed to load ${crypto.name}:`, e);
                    }
                }
                
                // Fear & Greed
                loadingStatus.textContent = 'Loading Fear & Greed Index...';
                state.fearGreed = await fetchFearGreedIndex();
                updateFearGreedUI();
                
                // Calculate parameters
                loadingStatus.textContent = 'Calculating indicators...';
                await calculateAllParameters(state.currentCrypto);
                
                // Generate initial predictions
                loadingStatus.textContent = 'Generating predictions...';
                generatePredictions(state.currentCrypto);
                
                // Update UI
                updateLivePriceUI();
                updateTabPrices();
                renderParameterHeatmap(state.parameters[state.currentCrypto]);
                renderPredictionCards();
                updateCharts();
                updateStatsUI();
                
                // Connect WebSocket
                loadingStatus.textContent = 'Connecting to live feed...';
                initWebSocket();
                
                // Hide loading
                document.getElementById('loadingOverlay').style.display = 'none';
                
                // Start timers
                setInterval(updateCurrentTime, 1000);
                setInterval(updateCountdown, 1000);
                setInterval(checkExpiredPredictions, 1000);
                setInterval(renderPredictionCards, 5000);
                
                // Refresh Fear & Greed every 5 minutes
                setInterval(async () => {
                    state.fearGreed = await fetchFearGreedIndex();
                    updateFearGreedUI();
                }, 300000);
                
                // Recalculate parameters every 30 seconds
                setInterval(async () => {
                    await calculateAllParameters(state.currentCrypto);
                    renderParameterHeatmap(state.parameters[state.currentCrypto]);
                    updateCharts();
                }, 30000);
                
                console.log('âœ… CryptoOracle Pro initialized!');
                
            } catch (error) {
                console.error('âŒ Initialization failed:', error);
                document.getElementById('loadingOverlay').innerHTML = `
                    <div class="text-center">
                        <div class="title-font text-xl text-red-400 mb-2">Connection Failed</div>
                        <div class="text-sm text-gray-400 mb-4">${error.message}</div>
                        <button onclick="location.reload()" class="px-4 py-2 bg-purple-600 rounded hover:bg-purple-700">Retry</button>
                    </div>
                `;
            }
        }

        // Start
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
