<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoOracle Pro - AI Prediction Engine (Bybit)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-green: #00ff88;
            --neon-red: #ff3366;
            --neon-purple: #9945ff;
            --neon-blue: #00d4ff;
            --neon-orange: #ff9500;
            --glass-bg: rgba(15, 15, 35, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .neon-glow-green {
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3), 0 0 40px rgba(0, 255, 136, 0.1);
        }

        .neon-glow-red {
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.3), 0 0 40px rgba(255, 51, 102, 0.1);
        }

        .neon-glow-purple {
            box-shadow: 0 0 20px rgba(153, 69, 255, 0.3), 0 0 40px rgba(153, 69, 255, 0.1);
        }

        .title-font {
            font-family: 'Orbitron', monospace;
        }

        .gauge-container {
            position: relative;
            width: 280px;
            height: 160px;
        }

        .gauge-bg {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .gauge-needle {
            position: absolute;
            bottom: 10px;
            left: 50%;
            width: 4px;
            height: 100px;
            background: linear-gradient(to top, #fff, transparent);
            transform-origin: bottom center;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 2px;
        }

        .param-block {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .param-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .param-block.bullish::before {
            background: radial-gradient(ellipse at center, var(--neon-green), transparent 70%);
        }

        .param-block.bearish::before {
            background: radial-gradient(ellipse at center, var(--neon-red), transparent 70%);
        }

        .param-block.neutral::before {
            background: radial-gradient(ellipse at center, var(--neon-purple), transparent 70%);
        }

        .crypto-tab {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .crypto-tab.active {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(153, 69, 255, 0.2));
            border-color: var(--neon-green);
        }

        .countdown-ring {
            stroke-dasharray: 283;
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear;
        }

        .prediction-card {
            transition: all 0.3s ease;
        }

        .prediction-card:hover {
            transform: translateY(-5px);
        }

        .pulse-dot {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
            animation: scan 3s linear infinite;
        }

        @keyframes scan {
            0% { top: 0; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        .loading-bar {
            background: linear-gradient(90deg, var(--neon-green), var(--neon-purple), var(--neon-blue));
            background-size: 200% 100%;
            animation: loading 1.5s ease infinite;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .stat-value {
            font-variant-numeric: tabular-nums;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--neon-purple);
            border-radius: 4px;
        }

        .leverage-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: linear-gradient(135deg, var(--neon-orange), var(--neon-red));
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
        }

        .connection-status.connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .connection-status.disconnected {
            background: rgba(255, 51, 102, 0.2);
            border: 1px solid rgba(255, 51, 102, 0.3);
        }

        .connection-status.connecting {
            background: rgba(255, 149, 0, 0.2);
            border: 1px solid rgba(255, 149, 0, 0.3);
        }

        .funding-rate {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .funding-rate.positive {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .funding-rate.negative {
            background: rgba(255, 51, 102, 0.2);
            color: #ff3366;
        }
    </style>
</head>
<body>
    <div class="cyber-grid"></div>
    
    <!-- Header -->
    <header class="relative z-10 p-4 border-b border-white/10">
        <div class="max-w-7xl mx-auto flex items-center justify-between flex-wrap gap-4">
            <div class="flex items-center gap-4">
                <div class="w-12 h-12 rounded-xl bg-gradient-to-br from-green-400 to-purple-600 flex items-center justify-center">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                    </svg>
                </div>
                <div>
                    <h1 class="title-font text-2xl font-bold bg-gradient-to-r from-green-400 via-purple-400 to-blue-400 bg-clip-text text-transparent">
                        CRYPTOORACLE PRO
                    </h1>
                    <p class="text-xs text-gray-400">Bybit Real-Time Data â€¢ AI Prediction Engine</p>
                </div>
            </div>
            
            <div class="flex items-center gap-4 flex-wrap">
                <!-- WebSocket Status -->
                <div id="wsStatus" class="connection-status connecting">
                    <div class="w-2 h-2 rounded-full bg-orange-400 animate-pulse"></div>
                    <span>Connecting...</span>
                </div>

                <div class="glass-panel px-4 py-2 flex items-center gap-3">
                    <div class="pulse-dot w-2 h-2 rounded-full bg-green-400"></div>
                    <span class="text-sm text-gray-300">LIVE</span>
                    <span id="currentTime" class="title-font text-green-400">--:--:--</span>
                </div>
                
                <div class="glass-panel px-4 py-2">
                    <div class="text-xs text-gray-400">24H Accuracy</div>
                    <div id="accuracy24h" class="title-font text-xl text-green-400">--%</div>
                </div>
                
                <div class="glass-panel px-4 py-2">
                    <div class="text-xs text-gray-400">Total Trades</div>
                    <div id="totalTrades" class="title-font text-xl text-purple-400">--</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Crypto Tabs -->
    <nav class="relative z-10 p-4">
        <div class="max-w-7xl mx-auto flex gap-3 overflow-x-auto pb-2" id="cryptoTabs">
            <!-- Tabs will be generated by JS -->
        </div>
    </nav>

    <!-- Main Dashboard -->
    <main class="relative z-10 p-4 max-w-7xl mx-auto">
        <!-- Top Row: CPS Gauge + Live Price + Quick Stats -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-4 mb-4">
            <!-- CPS Master Gauge -->
            <div class="glass-panel p-6 neon-glow-purple col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">COMPOSITE PREDICTIVE SCORE</h3>
                <div class="flex flex-col items-center">
                    <div class="gauge-container mb-4">
                        <svg class="gauge-bg" viewBox="0 0 200 120">
                            <defs>
                                <linearGradient id="gaugeGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#ff3366"/>
                                    <stop offset="50%" style="stop-color:#9945ff"/>
                                    <stop offset="100%" style="stop-color:#00ff88"/>
                                </linearGradient>
                            </defs>
                            <path d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="url(#gaugeGrad)" stroke-width="12" stroke-linecap="round"/>
                            <path d="M 20 100 A 80 80 0 0 1 180 100" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="20" stroke-linecap="round"/>
                        </svg>
                        <div id="gaugeNeedle" class="gauge-needle" style="transform: rotate(-90deg);"></div>
                        <div class="absolute bottom-0 left-0 right-0 text-center">
                            <div id="cpsValue" class="title-font text-4xl font-bold">--</div>
                            <div id="cpsLabel" class="text-sm text-gray-400">CALCULATING...</div>
                        </div>
                    </div>
                    <div class="flex justify-between w-full text-xs text-gray-500">
                        <span>STRONG SELL</span>
                        <span>NEUTRAL</span>
                        <span>STRONG BUY</span>
                    </div>
                </div>
            </div>

            <!-- Live Price Panel -->
            <div class="glass-panel p-6 col-span-1">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="title-font text-sm text-gray-400">LIVE PRICE</h3>
                    <span id="fundingRate" class="funding-rate">Funding: --%</span>
                </div>
                <div id="livePrice" class="title-font text-4xl font-bold text-white mb-2">$--,---</div>
                <div class="flex items-center gap-2">
                    <span id="priceChange" class="text-lg">--%</span>
                    <span class="text-xs text-gray-500">24H</span>
                </div>
                <div class="mt-4 grid grid-cols-2 gap-2 text-xs">
                    <div>
                        <div class="text-gray-500">24H High</div>
                        <div id="high24h" class="text-green-400">$--</div>
                    </div>
                    <div>
                        <div class="text-gray-500">24H Low</div>
                        <div id="low24h" class="text-red-400">$--</div>
                    </div>
                    <div>
                        <div class="text-gray-500">24H Volume</div>
                        <div id="volume24h" class="text-purple-400">$--</div>
                    </div>
                    <div>
                        <div class="text-gray-500">Open Interest</div>
                        <div id="openInterest" class="text-blue-400">$--</div>
                    </div>
                </div>
            </div>

            <!-- Countdown Timer & Next Update -->
            <div class="glass-panel p-6 col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">NEXT ANALYSIS</h3>
                <div class="flex items-center justify-center mb-4">
                    <div class="relative">
                        <svg class="w-24 h-24 transform -rotate-90">
                            <circle cx="48" cy="48" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="6"/>
                            <circle id="countdownRing" class="countdown-ring" cx="48" cy="48" r="45" fill="none" stroke="url(#gaugeGrad)" stroke-width="6" stroke-linecap="round"/>
                        </svg>
                        <div class="absolute inset-0 flex items-center justify-center">
                            <span id="countdownText" class="title-font text-2xl">--:--</span>
                        </div>
                    </div>
                </div>
                <div class="text-center">
                    <div id="activeInterval" class="text-sm text-purple-400">1 MIN INTERVAL</div>
                    <div class="text-xs text-gray-500 mt-1">Auto-refresh enabled</div>
                </div>
            </div>

            <!-- Fear & Greed Index -->
            <div class="glass-panel p-6 col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">FEAR & GREED INDEX</h3>
                <div class="flex items-center justify-center">
                    <div id="fearGreedGauge" class="relative w-32 h-32">
                        <svg viewBox="0 0 100 100" class="w-full h-full">
                            <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="8"/>
                            <circle id="fgCircle" cx="50" cy="50" r="45" fill="none" stroke="var(--neon-orange)" stroke-width="8" stroke-linecap="round" stroke-dasharray="283" stroke-dashoffset="141" transform="rotate(-90 50 50)"/>
                        </svg>
                        <div class="absolute inset-0 flex flex-col items-center justify-center">
                            <span id="fgValue" class="title-font text-3xl font-bold">--</span>
                            <span id="fgLabel" class="text-xs text-gray-400">LOADING</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Prediction Cards Row -->
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-7 gap-3 mb-4" id="predictionCards">
            <!-- Cards generated by JS -->
        </div>

        <!-- Main Chart Area -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-4">
            <!-- Price Chart with Predictions -->
            <div class="glass-panel p-6 col-span-2 relative overflow-hidden">
                <div class="scan-line"></div>
                <div class="flex items-center justify-between mb-4">
                    <h3 class="title-font text-sm text-gray-400">PRICE vs PREDICTION OVERLAY</h3>
                    <div class="flex gap-2">
                        <button onclick="setChartRange('1h')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/10 hover:bg-white/20">1H</button>
                        <button onclick="setChartRange('4h')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/10 hover:bg-white/20">4H</button>
                        <button onclick="setChartRange('1d')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/20 border border-purple-500">1D</button>
                        <button onclick="setChartRange('1w')" class="chart-range-btn px-3 py-1 text-xs rounded bg-white/10 hover:bg-white/20">1W</button>
                    </div>
                </div>
                <div class="h-80">
                    <canvas id="priceChart"></canvas>
                </div>
                <div class="flex items-center gap-6 mt-4 text-xs">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-blue-400"></div>
                        <span>Actual Price</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-green-400"></div>
                        <span>Predicted Price</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-1 bg-purple-400/50"></div>
                        <span>Confidence Band</span>
                    </div>
                </div>
            </div>

            <!-- Parameters Heatmap -->
            <div class="glass-panel p-6 col-span-1">
                <h3 class="title-font text-sm text-gray-400 mb-4">PARAMETER INTENSITY (Real Data)</h3>
                <div id="paramHeatmap" class="grid grid-cols-2 gap-2">
                    <!-- Generated by JS -->
                </div>
            </div>
        </div>

        <!-- Historical Performance & Trade Log -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
            <!-- Historical Performance Chart -->
            <div class="glass-panel p-6">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="title-font text-sm text-gray-400">HISTORICAL PERFORMANCE</h3>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">Win Rate:</span>
                        <span id="winRate" class="title-font text-green-400">--%</span>
                    </div>
                </div>
                <div class="h-64">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <!-- Trade History Log -->
            <div class="glass-panel p-6">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="title-font text-sm text-gray-400">TRADE HISTORY</h3>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">P/L:</span>
                        <span id="totalPL" class="title-font text-green-400">+$--</span>
                    </div>
                </div>
                <div class="overflow-y-auto max-h-56" id="tradeHistory">
                    <!-- Generated by JS -->
                </div>
            </div>
        </div>

        <!-- Bottom Stats Grid -->
        <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Winning Trades</div>
                <div id="winningTrades" class="title-font text-2xl text-green-400">--</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Losing Trades</div>
                <div id="losingTrades" class="title-font text-2xl text-red-400">--</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Avg Profit</div>
                <div id="avgProfit" class="title-font text-2xl text-green-400">+$--</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Avg Loss</div>
                <div id="avgLoss" class="title-font text-2xl text-red-400">-$--</div>
            </div>
            <div class="glass-panel p-4 text-center">
                <div class="text-xs text-gray-500">Current Leverage</div>
                <div id="currentLeverage" class="title-font text-2xl text-orange-400">1x</div>
            </div>
        </div>
    </main>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center">
        <div class="text-center">
            <div class="w-16 h-16 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
            <div class="title-font text-xl text-white mb-2">INITIALIZING ORACLE</div>
            <div id="loadingStatus" class="text-sm text-gray-400">Connecting to Bybit...</div>
            <div class="w-64 h-1 bg-gray-800 rounded-full mt-4 overflow-hidden">
                <div class="loading-bar h-full rounded-full"></div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // CRYPTOORACLE PRO - BYBIT REAL-TIME VERSION
        // ==========================================

        // Configuration
        const CONFIG = {
            cryptos: [
                { id: 'BTCUSDT', symbol: 'BTC', name: 'Bitcoin', color: '#f7931a' },
                { id: 'ETHUSDT', symbol: 'ETH', name: 'Ethereum', color: '#627eea' },
                { id: 'SOLUSDT', symbol: 'SOL', name: 'Solana', color: '#00ffa3' },
                { id: 'BNBUSDT', symbol: 'BNB', name: 'BNB', color: '#f3ba2f' },
                { id: 'XRPUSDT', symbol: 'XRP', name: 'XRP', color: '#00aae4' }
            ],
            intervals: [
                { label: '1 MIN', seconds: 60, key: '1m', bybit: '1' },
                { label: '5 MIN', seconds: 300, key: '5m', bybit: '5' },
                { label: '15 MIN', seconds: 900, key: '15m', bybit: '15' },
                { label: '1 HOUR', seconds: 3600, key: '1h', bybit: '60' },
                { label: '4 HOURS', seconds: 14400, key: '4h', bybit: '240' },
                { label: '1 DAY', seconds: 86400, key: '1d', bybit: 'D' },
                { label: '1 WEEK', seconds: 604800, key: '1w', bybit: 'W' }
            ],
            baseInvestment: 100,
            maxLeverage: 5,
            deviationThreshold: 0.05,
            bybitRestUrl: 'https://api.bybit.com',
            bybitWsUrl: 'wss://stream.bybit.com/v5/public/linear'
        };

        // State Management
        const state = {
            currentCrypto: 'BTCUSDT',
            currentInterval: 0,
            currentChartRange: '1d',
            prices: {},
            klines: {},
            predictions: {},
            parameters: {},
            fundingRates: {},
            openInterest: {},
            orderbooks: {},
            weights: {
                rsi: 0.12,
                macd: 0.10,
                bollingerBands: 0.08,
                fundingRate: 0.15,
                openInterest: 0.12,
                volumeProfile: 0.10,
                priceAction: 0.10,
                orderbook: 0.08,
                fearGreed: 0.08,
                momentum: 0.07
            },
            tradeHistory: [],
            stats: {
                totalTrades: 0,
                winningTrades: 0,
                losingTrades: 0,
                totalPL: 0,
                accuracy24h: 0
            },
            leverage: 1,
            countdownSeconds: 60,
            charts: {},
            lastUpdate: null,
            ws: null,
            wsConnected: false,
            fearGreed: { value: 50, classification: 'Neutral' }
        };

        // ==========================================
        // BYBIT API FUNCTIONS
        // ==========================================

        async function fetchBybitTicker(symbol) {
            try {
                const response = await fetch(`${CONFIG.bybitRestUrl}/v5/market/tickers?category=linear&symbol=${symbol}`);
                const data = await response.json();
                
                if (data.retCode === 0 && data.result.list.length > 0) {
                    const ticker = data.result.list[0];
                    return {
                        price: parseFloat(ticker.lastPrice),
                        change24h: parseFloat(ticker.price24hPcnt) * 100,
                        high24h: parseFloat(ticker.highPrice24h),
                        low24h: parseFloat(ticker.lowPrice24h),
                        volume24h: parseFloat(ticker.turnover24h),
                        fundingRate: parseFloat(ticker.fundingRate) * 100,
                        nextFundingTime: parseInt(ticker.nextFundingTime),
                        bid: parseFloat(ticker.bid1Price),
                        ask: parseFloat(ticker.ask1Price)
                    };
                }
                throw new Error('Invalid response');
            } catch (error) {
                console.error('Error fetching Bybit ticker:', error);
                return null;
            }
        }

        async function fetchBybitKlines(symbol, interval = '60', limit = 200) {
            try {
                const response = await fetch(
                    `${CONFIG.bybitRestUrl}/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${limit}`
                );
                const data = await response.json();
                
                if (data.retCode === 0 && data.result.list.length > 0) {
                    // Bybit returns newest first, we need to reverse
                    return data.result.list.reverse().map(k => ({
                        timestamp: parseInt(k[0]),
                        open: parseFloat(k[1]),
                        high: parseFloat(k[2]),
                        low: parseFloat(k[3]),
                        close: parseFloat(k[4]),
                        volume: parseFloat(k[5]),
                        turnover: parseFloat(k[6])
                    }));
                }
                throw new Error('Invalid response');
            } catch (error) {
                console.error('Error fetching Bybit klines:', error);
                return [];
            }
        }

        async function fetchBybitOpenInterest(symbol) {
            try {
                const response = await fetch(
                    `${CONFIG.bybitRestUrl}/v5/market/open-interest?category=linear&symbol=${symbol}&intervalTime=1h&limit=1`
                );
                const data = await response.json();
                
                if (data.retCode === 0 && data.result.list.length > 0) {
                    return {
                        openInterest: parseFloat(data.result.list[0].openInterest),
                        timestamp: parseInt(data.result.list[0].timestamp)
                    };
                }
                throw new Error('Invalid response');
            } catch (error) {
                console.error('Error fetching open interest:', error);
                return { openInterest: 0 };
            }
        }

        async function fetchBybitOrderbook(symbol, limit = 25) {
            try {
                const response = await fetch(
                    `${CONFIG.bybitRestUrl}/v5/market/orderbook?category=linear&symbol=${symbol}&limit=${limit}`
                );
                const data = await response.json();
                
                if (data.retCode === 0) {
                    const bids = data.result.b.map(b => ({ price: parseFloat(b[0]), qty: parseFloat(b[1]) }));
                    const asks = data.result.a.map(a => ({ price: parseFloat(a[0]), qty: parseFloat(a[1]) }));
                    
                    const bidTotal = bids.reduce((sum, b) => sum + b.qty, 0);
                    const askTotal = asks.reduce((sum, a) => sum + a.qty, 0);
                    
                    return {
                        bids,
                        asks,
                        bidTotal,
                        askTotal,
                        imbalance: (bidTotal - askTotal) / (bidTotal + askTotal) // -1 to 1
                    };
                }
                throw new Error('Invalid response');
            } catch (error) {
                console.error('Error fetching orderbook:', error);
                return { imbalance: 0 };
            }
        }

        async function fetchFearGreedIndex() {
            try {
                const response = await fetch('https://api.alternative.me/fng/?limit=1');
                const data = await response.json();
                
                if (data && data.data && data.data.length > 0) {
                    return {
                        value: parseInt(data.data[0].value),
                        classification: data.data[0].value_classification
                    };
                }
            } catch (error) {
                console.error('Error fetching Fear & Greed:', error);
            }
            return { value: 50, classification: 'Neutral' };
        }

        // ==========================================
        // WEBSOCKET CONNECTION
        // ==========================================

        function initWebSocket() {
            updateWSStatus('connecting');
            
            state.ws = new WebSocket(CONFIG.bybitWsUrl);
            
            state.ws.onopen = () => {
                console.log('WebSocket connected to Bybit');
                state.wsConnected = true;
                updateWSStatus('connected');
                
                // Subscribe to all crypto tickers
                const symbols = CONFIG.cryptos.map(c => c.id);
                const subscribeMsg = {
                    op: 'subscribe',
                    args: symbols.map(s => `tickers.${s}`)
                };
                state.ws.send(JSON.stringify(subscribeMsg));
                
                // Also subscribe to klines for current crypto
                subscribeToKlines(state.currentCrypto);
            };
            
            state.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.topic && data.topic.startsWith('tickers.')) {
                        handleTickerUpdate(data);
                    } else if (data.topic && data.topic.startsWith('kline.')) {
                        handleKlineUpdate(data);
                    }
                } catch (error) {
                    console.error('Error parsing WS message:', error);
                }
            };
            
            state.ws.onclose = () => {
                console.log('WebSocket disconnected');
                state.wsConnected = false;
                updateWSStatus('disconnected');
                
                // Reconnect after 5 seconds
                setTimeout(initWebSocket, 5000);
            };
            
            state.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateWSStatus('disconnected');
            };
        }

        function subscribeToKlines(symbol) {
            if (state.ws && state.wsConnected) {
                const interval = CONFIG.intervals[state.currentInterval].bybit;
                const subscribeMsg = {
                    op: 'subscribe',
                    args: [`kline.${interval}.${symbol}`]
                };
                state.ws.send(JSON.stringify(subscribeMsg));
            }
        }

        function handleTickerUpdate(data) {
            const symbol = data.topic.replace('tickers.', '');
            const ticker = data.data;
            
            state.prices[symbol] = {
                price: parseFloat(ticker.lastPrice),
                change24h: parseFloat(ticker.price24hPcnt) * 100,
                high24h: parseFloat(ticker.highPrice24h),
                low24h: parseFloat(ticker.lowPrice24h),
                volume24h: parseFloat(ticker.turnover24h),
                fundingRate: parseFloat(ticker.fundingRate) * 100,
                bid: parseFloat(ticker.bid1Price),
                ask: parseFloat(ticker.ask1Price),
                timestamp: Date.now()
            };
            
            // Update UI if it's the current crypto
            if (symbol === state.currentCrypto) {
                updateLivePriceUI();
            }
            
            // Update tab prices
            updateTabPrices();
        }

        function handleKlineUpdate(data) {
            if (data.data && data.data.length > 0) {
                const kline = data.data[0];
                const symbol = data.topic.split('.')[2];
                
                if (!state.klines[symbol]) {
                    state.klines[symbol] = [];
                }
                
                const newKline = {
                    timestamp: parseInt(kline.start),
                    open: parseFloat(kline.open),
                    high: parseFloat(kline.high),
                    low: parseFloat(kline.low),
                    close: parseFloat(kline.close),
                    volume: parseFloat(kline.volume),
                    confirm: kline.confirm
                };
                
                // Update or add kline
                const existingIndex = state.klines[symbol].findIndex(k => k.timestamp === newKline.timestamp);
                if (existingIndex >= 0) {
                    state.klines[symbol][existingIndex] = newKline;
                } else {
                    state.klines[symbol].push(newKline);
                    // Keep only last 200 klines
                    if (state.klines[symbol].length > 200) {
                        state.klines[symbol].shift();
                    }
                }
                
                // If kline is confirmed, recalculate indicators
                if (kline.confirm && symbol === state.currentCrypto) {
                    calculateAllParameters(symbol);
                    updateCharts();
                }
            }
        }

        function updateWSStatus(status) {
            const wsStatusEl = document.getElementById('wsStatus');
            if (!wsStatusEl) return;
            
            wsStatusEl.className = `connection-status ${status}`;
            
            const statusText = {
                connected: '<div class="w-2 h-2 rounded-full bg-green-400"></div><span>Connected</span>',
                disconnected: '<div class="w-2 h-2 rounded-full bg-red-400"></div><span>Disconnected</span>',
                connecting: '<div class="w-2 h-2 rounded-full bg-orange-400 animate-pulse"></div><span>Connecting...</span>'
            };
            
            wsStatusEl.innerHTML = statusText[status] || statusText.connecting;
        }

        // ==========================================
        // TECHNICAL INDICATORS CALCULATION
        // ==========================================

        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateMACD(prices) {
            if (prices.length < 26) return { macd: 0, signal: 0, histogram: 0 };
            
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            const macd = ema12 - ema26;
            
            // Simplified signal line (would need historical MACD values for accurate calculation)
            const signal = macd * 0.9;
            const histogram = macd - signal;
            
            return { macd, signal, histogram };
        }

        function calculateEMA(prices, period) {
            if (prices.length < period) return prices[prices.length - 1] || 0;
            
            const k = 2 / (period + 1);
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            for (let i = period; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
            }
            return ema;
        }

        function calculateBollingerBands(prices, period = 20) {
            if (prices.length < period) return { upper: 0, middle: 0, lower: 0, percentB: 0.5 };
            
            const recentPrices = prices.slice(-period);
            const sma = recentPrices.reduce((a, b) => a + b, 0) / period;
            const std = Math.sqrt(recentPrices.reduce((sum, p) => sum + Math.pow(p - sma, 2), 0) / period);
            
            const upper = sma + 2 * std;
            const lower = sma - 2 * std;
            const currentPrice = prices[prices.length - 1];
            const percentB = std > 0 ? (currentPrice - lower) / (upper - lower) : 0.5;
            
            return { upper, middle: sma, lower, percentB };
        }

        function calculateMomentum(prices, period = 10) {
            if (prices.length < period + 1) return 0;
            const current = prices[prices.length - 1];
            const past = prices[prices.length - period - 1];
            return ((current - past) / past) * 100;
        }

        function calculateVolumeProfile(klines) {
            if (klines.length < 20) return 0;
            
            const recentKlines = klines.slice(-20);
            const avgVolume = recentKlines.reduce((sum, k) => sum + k.volume, 0) / 20;
            const lastVolume = recentKlines[recentKlines.length - 1].volume;
            
            // Positive if volume is above average (bullish), negative if below
            return (lastVolume - avgVolume) / avgVolume;
        }

        function calculatePriceAction(klines) {
            if (klines.length < 5) return 0;
            
            const recent = klines.slice(-5);
            let bullishCandles = 0;
            let bearishCandles = 0;
            
            recent.forEach(k => {
                if (k.close > k.open) bullishCandles++;
                else if (k.close < k.open) bearishCandles++;
            });
            
            return (bullishCandles - bearishCandles) / 5;
        }

        async function calculateAllParameters(symbol) {
            const priceData = state.prices[symbol];
            const klines = state.klines[symbol] || [];
            const prices = klines.map(k => k.close);
            
            if (prices.length < 26) {
                console.log('Not enough data for calculations');
                return;
            }
            
            // Calculate all indicators
            const rsi = calculateRSI(prices);
            const macd = calculateMACD(prices);
            const bb = calculateBollingerBands(prices);
            const momentum = calculateMomentum(prices);
            const volumeProfile = calculateVolumeProfile(klines);
            const priceAction = calculatePriceAction(klines);
            
            // Fetch additional data
            const orderbook = await fetchBybitOrderbook(symbol);
            const oi = await fetchBybitOpenInterest(symbol);
            
            state.openInterest[symbol] = oi.openInterest;
            state.orderbooks[symbol] = orderbook;
            
            // Normalize all parameters to -1 to 1 range
            const params = {
                rsi: (rsi - 50) / 50, // RSI: <30 bullish, >70 bearish
                macd: Math.max(-1, Math.min(1, macd.histogram / (priceData?.price || 1) * 1000)),
                bollingerBands: (bb.percentB - 0.5) * 2, // %B: <0.2 bullish, >0.8 bearish
                fundingRate: priceData?.fundingRate ? -Math.max(-1, Math.min(1, priceData.fundingRate * 10)) : 0, // Negative funding = bullish
                openInterest: 0.5, // Would need historical OI to calculate change
                volumeProfile: Math.max(-1, Math.min(1, volumeProfile)),
                priceAction: priceAction,
                orderbook: orderbook.imbalance || 0,
                fearGreed: (state.fearGreed.value - 50) / 50,
                momentum: Math.max(-1, Math.min(1, momentum / 10))
            };
            
            state.parameters[symbol] = params;
            
            // Update UI
            if (symbol === state.currentCrypto) {
                renderParameterHeatmap(params);
                updateCPSGauge(params);
            }
        }

        // ==========================================
        // COMPOSITE PREDICTIVE SCORE (CPS)
        // ==========================================

        function calculateCPS(params) {
            if (!params) return 0;
            
            const w = state.weights;
            
            const cps = (
                w.rsi * params.rsi +
                w.macd * params.macd +
                w.bollingerBands * (-params.bollingerBands) + // Invert: low %B = buy signal
                w.fundingRate * params.fundingRate +
                w.openInterest * params.openInterest +
                w.volumeProfile * params.volumeProfile +
                w.priceAction * params.priceAction +
                w.orderbook * params.orderbook +
                w.fearGreed * (-params.fearGreed) + // Invert: extreme fear = buy signal
                w.momentum * params.momentum
            );
            
            return Math.max(-1, Math.min(1, cps));
        }

        function getCPSLabel(cps) {
            if (cps >= 0.6) return { label: 'STRONG BUY', color: '#00ff88', direction: 'LONG' };
            if (cps >= 0.2) return { label: 'BUY', color: '#00dd66', direction: 'LONG' };
            if (cps >= -0.2) return { label: 'NEUTRAL', color: '#9945ff', direction: 'HOLD' };
            if (cps >= -0.6) return { label: 'SELL', color: '#ff6644', direction: 'SHORT' };
            return { label: 'STRONG SELL', color: '#ff3366', direction: 'SHORT' };
        }

        function updateCPSGauge(params) {
            const cps = calculateCPS(params);
            const cpsInfo = getCPSLabel(cps);
            
            const angle = -90 + (cps + 1) * 90;
            document.getElementById('gaugeNeedle').style.transform = `rotate(${angle}deg)`;
            
            const cpsValueEl = document.getElementById('cpsValue');
            const cpsLabelEl = document.getElementById('cpsLabel');
            
            cpsValueEl.textContent = (cps * 100).toFixed(0);
            cpsValueEl.style.color = cpsInfo.color;
            cpsLabelEl.textContent = cpsInfo.label;
            cpsLabelEl.style.color = cpsInfo.color;
        }

        // ==========================================
        // PREDICTION ENGINE
        // ==========================================

        function generatePrediction(currentPrice, cps, interval) {
            const volatilityFactor = 0.015;
            const timeMultiplier = Math.sqrt(interval.seconds / 60);
            
            const direction = cps > 0 ? 1 : -1;
            const magnitude = Math.abs(cps);
            
            const expectedMove = currentPrice * volatilityFactor * timeMultiplier * magnitude * direction;
            const predictedPrice = currentPrice + expectedMove;
            
            const confidence = Math.max(50, 100 - (timeMultiplier * 5) - (1 - magnitude) * 20);
            const spread = currentPrice * volatilityFactor * timeMultiplier * 2;
            
            const expectedPLPercent = ((predictedPrice - currentPrice) / currentPrice) * 100 * state.leverage;
            const expectedPLDollar = (CONFIG.baseInvestment * expectedPLPercent) / 100;
            
            return {
                targetPrice: predictedPrice,
                direction: direction > 0 ? 'LONG' : 'SHORT',
                confidence: confidence,
                upperBound: predictedPrice + spread,
                lowerBound: predictedPrice - spread,
                expectedPLPercent: expectedPLPercent,
                expectedPLDollar: expectedPLDollar,
                timestamp: Date.now(),
                interval: interval.key,
                expiresAt: Date.now() + (interval.seconds * 1000)
            };
        }

        function executePrediction(prediction, params) {
            const trade = {
                id: Date.now(),
                crypto: state.currentCrypto,
                entryPrice: state.prices[state.currentCrypto]?.price || 0,
                targetPrice: prediction.targetPrice,
                direction: prediction.direction,
                interval: prediction.interval,
                leverage: state.leverage,
                investment: CONFIG.baseInvestment,
                confidence: prediction.confidence,
                parameters: { ...params },
                cps: calculateCPS(params),
                timestamp: Date.now(),
                expiresAt: prediction.expiresAt,
                status: 'ACTIVE',
                actualPL: null,
                exitPrice: null
            };

            if (!state.predictions[state.currentCrypto]) {
                state.predictions[state.currentCrypto] = {};
            }
            state.predictions[state.currentCrypto][prediction.interval] = trade;

            return trade;
        }

        function evaluateTrade(trade) {
            const currentPrice = state.prices[trade.crypto]?.price || trade.entryPrice;
            const priceChange = (currentPrice - trade.entryPrice) / trade.entryPrice;
            
            let pl;
            if (trade.direction === 'LONG') {
                pl = priceChange * trade.investment * trade.leverage;
            } else {
                pl = -priceChange * trade.investment * trade.leverage;
            }

            trade.exitPrice = currentPrice;
            trade.actualPL = pl;
            trade.status = pl > 0 ? 'WON' : 'LOST';

            state.stats.totalTrades++;
            if (pl > 0) {
                state.stats.winningTrades++;
            } else {
                state.stats.losingTrades++;
            }
            state.stats.totalPL += pl;

            state.tradeHistory.unshift(trade);
            if (state.tradeHistory.length > 100) {
                state.tradeHistory.pop();
            }

            // Recalibrate weights if deviation is large
            const deviation = Math.abs((currentPrice - trade.targetPrice) / trade.targetPrice);
            if (deviation > CONFIG.deviationThreshold) {
                optimizeWeights();
            }

            calculateOptimalLeverage();
            return trade;
        }

        function optimizeWeights() {
            const recentTrades = state.tradeHistory.slice(-30);
            if (recentTrades.length < 5) return;

            const paramNames = Object.keys(state.weights);
            const paramAccuracy = {};

            paramNames.forEach(param => {
                let correct = 0;
                let total = 0;
                
                recentTrades.forEach(trade => {
                    if (trade.parameters && trade.parameters[param] !== undefined) {
                        const paramDirection = trade.parameters[param] > 0 ? 1 : -1;
                        let tradeSuccess = trade.actualPL > 0 ? 1 : -1;
                        if (trade.direction === 'SHORT') tradeSuccess *= -1;
                        
                        if (paramDirection === tradeSuccess) correct++;
                        total++;
                    }
                });
                
                paramAccuracy[param] = total > 0 ? correct / total : 0.5;
            });

            const totalAccuracy = Object.values(paramAccuracy).reduce((a, b) => a + b, 0);
            if (totalAccuracy === 0) return;

            paramNames.forEach(param => {
                const newWeight = (paramAccuracy[param] / totalAccuracy) * 0.3 + state.weights[param] * 0.7;
                state.weights[param] = Math.max(0.05, Math.min(0.25, newWeight));
            });

            // Normalize
            const weightSum = Object.values(state.weights).reduce((a, b) => a + b, 0);
            paramNames.forEach(param => {
                state.weights[param] /= weightSum;
            });
            
            console.log('Weights optimized:', state.weights);
        }

        function calculateOptimalLeverage() {
            const recentTrades = state.tradeHistory.slice(-20);
            if (recentTrades.length < 5) return 1;

            const winRate = recentTrades.filter(t => t.actualPL > 0).length / recentTrades.length;
            
            if (winRate > 0.7 && state.leverage < CONFIG.maxLeverage) {
                state.leverage = Math.min(CONFIG.maxLeverage, state.leverage + 0.5);
            } else if (winRate < 0.4) {
                state.leverage = Math.max(1, state.leverage - 0.5);
            }

            return state.leverage;
        }

        // ==========================================
        // UI RENDERING FUNCTIONS
        // ==========================================

        function renderCryptoTabs() {
            const container = document.getElementById('cryptoTabs');
            container.innerHTML = CONFIG.cryptos.map(crypto => `
                <div class="crypto-tab glass-panel px-4 py-3 flex items-center gap-3 ${crypto.id === state.currentCrypto ? 'active' : ''}"
                     onclick="selectCrypto('${crypto.id}')" style="border-color: ${crypto.color}20">
                    <div class="w-8 h-8 rounded-full flex items-center justify-center" style="background: ${crypto.color}30">
                        <span class="title-font font-bold" style="color: ${crypto.color}">${crypto.symbol.charAt(0)}</span>
                    </div>
                    <div>
                        <div class="font-semibold">${crypto.symbol}</div>
                        <div class="text-xs text-gray-500">${crypto.name}</div>
                    </div>
                    <div class="ml-auto text-right">
                        <div id="tab-price-${crypto.id}" class="font-mono text-sm">$--</div>
                        <div id="tab-change-${crypto.id}" class="text-xs">--%</div>
                    </div>
                </div>
            `).join('');
        }

        function renderPredictionCards() {
            const container = document.getElementById('predictionCards');
            container.innerHTML = CONFIG.intervals.map((interval, idx) => `
                <div class="prediction-card glass-panel p-4 cursor-pointer ${idx === state.currentInterval ? 'neon-glow-purple' : ''}"
                     onclick="selectInterval(${idx})">
                    <div class="flex items-center justify-between mb-2">
                        <span class="title-font text-xs text-gray-400">${interval.label}</span>
                        ${state.leverage > 1 ? `<span class="leverage-badge">${state.leverage}x</span>` : ''}
                    </div>
                    <div id="pred-target-${interval.key}" class="title-font text-lg font-bold text-white">$--</div>
                    <div id="pred-direction-${interval.key}" class="text-xs text-gray-400 mb-2">--</div>
                    <div id="pred-pl-${interval.key}" class="title-font text-sm">$--</div>
                    <div class="mt-2 h-1 bg-gray-800 rounded-full overflow-hidden">
                        <div id="pred-progress-${interval.key}" class="h-full bg-purple-500 transition-all" style="width: 0%"></div>
                    </div>
                </div>
            `).join('');
        }

        function renderParameterHeatmap(params) {
            const paramNames = {
                rsi: { name: 'RSI', icon: 'ðŸ“Š' },
                macd: { name: 'MACD', icon: 'ðŸ“ˆ' },
                bollingerBands: { name: 'BB %B', icon: 'ðŸ“‰' },
                fundingRate: { name: 'FUNDING', icon: 'ðŸ’°' },
                openInterest: { name: 'OI', icon: 'ðŸŽ¯' },
                volumeProfile: { name: 'VOLUME', icon: 'ðŸ“Š' },
                priceAction: { name: 'PRICE', icon: 'ðŸ’¹' },
                orderbook: { name: 'ORDERS', icon: 'ðŸ“•' },
                fearGreed: { name: 'F&G', icon: 'ðŸ˜±' },
                momentum: { name: 'MOM', icon: 'ðŸš€' }
            };

            const container = document.getElementById('paramHeatmap');
            container.innerHTML = Object.entries(params).map(([key, value]) => {
                const info = paramNames[key] || { name: key, icon: 'â“' };
                const intensity = Math.abs(value);
                const isPositive = value > 0;
                const colorClass = isPositive ? 'bullish' : value < 0 ? 'bearish' : 'neutral';
                
                return `
                    <div class="param-block glass-panel p-3 ${colorClass}" style="opacity: ${0.5 + intensity * 0.5}">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-lg">${info.icon}</span>
                            <span class="text-xs font-mono ${isPositive ? 'text-green-400' : 'text-red-400'}">
                                ${value >= 0 ? '+' : ''}${(value * 100).toFixed(0)}%
                            </span>
                        </div>
                        <div class="text-xs text-gray-400">${info.name}</div>
                        <div class="text-xs text-gray-600">w: ${(state.weights[key] * 100).toFixed(1)}%</div>
                    </div>
                `;
            }).join('');
        }

        function updateLivePriceUI() {
            const priceData = state.prices[state.currentCrypto];
            if (!priceData) return;
            
            document.getElementById('livePrice').textContent = formatPrice(priceData.price);
            
            const changeEl = document.getElementById('priceChange');
            changeEl.textContent = `${priceData.change24h >= 0 ? '+' : ''}${priceData.change24h.toFixed(2)}%`;
            changeEl.className = `text-lg ${priceData.change24h >= 0 ? 'text-green-400' : 'text-red-400'}`;
            
            document.getElementById('high24h').textContent = formatPrice(priceData.high24h);
            document.getElementById('low24h').textContent = formatPrice(priceData.low24h);
            document.getElementById('volume24h').textContent = formatVolume(priceData.volume24h);
            
            // Funding rate
            const fundingEl = document.getElementById('fundingRate');
            if (priceData.fundingRate !== undefined) {
                fundingEl.textContent = `Funding: ${priceData.fundingRate >= 0 ? '+' : ''}${priceData.fundingRate.toFixed(4)}%`;
                fundingEl.className = `funding-rate ${priceData.fundingRate >= 0 ? 'positive' : 'negative'}`;
            }
            
            // Open Interest
            const oi = state.openInterest[state.currentCrypto];
            if (oi) {
                document.getElementById('openInterest').textContent = formatVolume(oi * priceData.price);
            }
        }

        function updateTabPrices() {
            CONFIG.cryptos.forEach(c => {
                const data = state.prices[c.id];
                if (data) {
                    const priceEl = document.getElementById(`tab-price-${c.id}`);
                    const changeEl = document.getElementById(`tab-change-${c.id}`);
                    
                    if (priceEl) priceEl.textContent = formatPrice(data.price);
                    if (changeEl) {
                        changeEl.textContent = `${data.change24h >= 0 ? '+' : ''}${data.change24h.toFixed(2)}%`;
                        changeEl.className = `text-xs ${data.change24h >= 0 ? 'text-green-400' : 'text-red-400'}`;
                    }
                }
            });
        }

        function renderTradeHistory() {
            const container = document.getElementById('tradeHistory');
            const trades = state.tradeHistory.slice(0, 10);
            
            if (trades.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-500 py-4">No trades yet</div>';
                return;
            }

            container.innerHTML = trades.map(trade => {
                const isWin = trade.actualPL > 0;
                const crypto = CONFIG.cryptos.find(c => c.id === trade.crypto);
                
                return `
                    <div class="flex items-center justify-between py-2 border-b border-white/5">
                        <div class="flex items-center gap-2">
                            <div class="w-2 h-2 rounded-full ${isWin ? 'bg-green-400' : 'bg-red-400'}"></div>
                            <span class="text-sm">${crypto?.symbol || trade.crypto}</span>
                            <span class="text-xs px-2 py-0.5 rounded ${trade.direction === 'LONG' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}">
                                ${trade.direction}
                            </span>
                            <span class="text-xs text-gray-500">${trade.interval}</span>
                        </div>
                        <div class="text-right">
                            <div class="text-sm ${isWin ? 'text-green-400' : 'text-red-400'}">
                                ${isWin ? '+' : ''}$${trade.actualPL?.toFixed(2) || '--'}
                            </div>
                            <div class="text-xs text-gray-600">
                                ${new Date(trade.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateStatsUI() {
            document.getElementById('accuracy24h').textContent = `${state.stats.accuracy24h.toFixed(1)}%`;
            document.getElementById('totalTrades').textContent = state.stats.totalTrades;
            document.getElementById('winningTrades').textContent = state.stats.winningTrades;
            document.getElementById('losingTrades').textContent = state.stats.losingTrades;
            
            const totalPLEl = document.getElementById('totalPL');
            totalPLEl.textContent = `${state.stats.totalPL >= 0 ? '+' : ''}$${state.stats.totalPL.toFixed(2)}`;
            totalPLEl.className = `title-font ${state.stats.totalPL >= 0 ? 'text-green-400' : 'text-red-400'}`;

            const winningTrades = state.tradeHistory.filter(t => t.actualPL > 0);
            const losingTrades = state.tradeHistory.filter(t => t.actualPL < 0);
            
            const avgProfit = winningTrades.length > 0 ? 
                winningTrades.reduce((sum, t) => sum + t.actualPL, 0) / winningTrades.length : 0;
            const avgLoss = losingTrades.length > 0 ? 
                Math.abs(losingTrades.reduce((sum, t) => sum + t.actualPL, 0)) / losingTrades.length : 0;

            document.getElementById('avgProfit').textContent = `+$${avgProfit.toFixed(2)}`;
            document.getElementById('avgLoss').textContent = `-$${avgLoss.toFixed(2)}`;
            
            const winRate = state.stats.totalTrades > 0 ? 
                (state.stats.winningTrades / state.stats.totalTrades) * 100 : 0;
            document.getElementById('winRate').textContent = `${winRate.toFixed(1)}%`;
            
            document.getElementById('currentLeverage').textContent = `${state.leverage.toFixed(1)}x`;
            
            renderTradeHistory();
        }

        function updatePredictionCards() {
            const crypto = state.currentCrypto;
            const predictions = state.predictions[crypto];
            const priceData = state.prices[crypto];
            
            if (!predictions || !priceData) return;
            
            CONFIG.intervals.forEach(interval => {
                const pred = predictions[interval.key];
                if (pred) {
                    const targetEl = document.getElementById(`pred-target-${interval.key}`);
                    const dirEl = document.getElementById(`pred-direction-${interval.key}`);
                    const plEl = document.getElementById(`pred-pl-${interval.key}`);
                    const progressEl = document.getElementById(`pred-progress-${interval.key}`);
                    
                    if (targetEl) targetEl.textContent = formatPrice(pred.targetPrice);
                    
                    if (dirEl) {
                        dirEl.textContent = `${pred.direction} (${pred.confidence.toFixed(0)}%)`;
                        dirEl.className = `text-xs ${pred.direction === 'LONG' ? 'text-green-400' : 'text-red-400'}`;
                    }

                    if (plEl) {
                        const currentPL = calculateCurrentPL(pred);
                        plEl.textContent = `${currentPL >= 0 ? '+' : ''}$${currentPL.toFixed(2)}`;
                        plEl.className = `title-font text-sm ${currentPL >= 0 ? 'text-green-400' : 'text-red-400'}`;
                    }

                    if (progressEl) {
                        const elapsed = Date.now() - pred.timestamp;
                        const total = pred.expiresAt - pred.timestamp;
                        const progress = total > 0 ? Math.min(100, (elapsed / total) * 100) : 0;
                        progressEl.style.width = `${progress}%`;
                    }
                }
            });
        }

        function calculateCurrentPL(trade) {
            const currentPrice = state.prices[trade.crypto]?.price || trade.entryPrice;
            const priceChange = (currentPrice - trade.entryPrice) / trade.entryPrice;
            
            if (trade.direction === 'LONG') {
                return priceChange * trade.investment * trade.leverage;
            } else {
                return -priceChange * trade.investment * trade.leverage;
            }
        }

        // ==========================================
        // CHART FUNCTIONS
        // ==========================================

        function initCharts() {
            const priceCtx = document.getElementById('priceChart');
            if (!priceCtx) return;
            
            state.charts.price = new Chart(priceCtx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Actual Price',
                            data: [],
                            borderColor: '#00d4ff',
                            backgroundColor: 'rgba(0, 212, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'Predicted Price',
                            data: [],
                            borderColor: '#00ff88',
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (ctx) => `${ctx.dataset.label}: $${ctx.parsed.y.toLocaleString()}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: 'rgba(255,255,255,0.5)', maxTicksLimit: 10 }
                        },
                        y: {
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { 
                                color: 'rgba(255,255,255,0.5)',
                                callback: (value) => '$' + formatNumber(value)
                            }
                        }
                    }
                }
            });

            const perfCtx = document.getElementById('performanceChart');
            if (!perfCtx) return;
            
            state.charts.performance = new Chart(perfCtx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'P/L',
                        data: [],
                        backgroundColor: [],
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { color: 'rgba(255,255,255,0.5)' }
                        },
                        y: {
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { 
                                color: 'rgba(255,255,255,0.5)',
                                callback: (value) => '$' + value.toFixed(0)
                            }
                        }
                    }
                }
            });
        }

        function updateCharts() {
            if (!state.charts.price || !state.charts.performance) return;

            const crypto = state.currentCrypto;
            const klines = state.klines[crypto] || [];
            const priceData = state.prices[crypto];
            const params = state.parameters[crypto];

            if (klines.length > 0) {
                // Determine how many candles to show based on range
                const rangeLimits = { '1h': 60, '4h': 48, '1d': 96, '1w': 168 };
                const limit = rangeLimits[state.currentChartRange] || 96;
                
                const displayKlines = klines.slice(-limit);
                const labels = displayKlines.map(k => {
                    const date = new Date(k.timestamp);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                });
                const prices = displayKlines.map(k => k.close);
                
                // Generate prediction line
                const lastPrice = prices[prices.length - 1] || priceData?.price || 0;
                const cps = params ? calculateCPS(params) : 0;
                
                // Add future predictions
                const futureCount = Math.floor(limit * 0.2);
                for (let i = 1; i <= futureCount; i++) {
                    labels.push(`+${i}`);
                    prices.push(null); // Actual price is null for future
                }
                
                // Predicted prices
                const predictedPrices = displayKlines.map(k => null);
                for (let i = 1; i <= futureCount; i++) {
                    const predPrice = lastPrice * (1 + cps * 0.001 * i);
                    predictedPrices.push(predPrice);
                }
                
                // Add last actual price to prediction line for continuity
                predictedPrices[predictedPrices.length - futureCount - 1] = lastPrice;

                state.charts.price.data.labels = labels;
                state.charts.price.data.datasets[0].data = prices;
                state.charts.price.data.datasets[1].data = predictedPrices;
                state.charts.price.update('none');
            }

            // Update performance chart
            const recentTrades = state.tradeHistory.slice(0, 10).reverse();
            state.charts.performance.data.labels = recentTrades.map((_, i) => `#${i + 1}`);
            state.charts.performance.data.datasets[0].data = recentTrades.map(t => t.actualPL || 0);
            state.charts.performance.data.datasets[0].backgroundColor = recentTrades.map(t => 
                t.actualPL > 0 ? 'rgba(0, 255, 136, 0.7)' : 'rgba(255, 51, 102, 0.7)'
            );
            state.charts.performance.update('none');
        }

        // ==========================================
        // COUNTDOWN & ANALYSIS
        // ==========================================

        function updateCountdown() {
            state.countdownSeconds--;
            
            if (state.countdownSeconds <= 0) {
                state.countdownSeconds = CONFIG.intervals[state.currentInterval].seconds;
                triggerAnalysis();
            }

            const minutes = Math.floor(state.countdownSeconds / 60);
            const seconds = state.countdownSeconds % 60;
            document.getElementById('countdownText').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            const total = CONFIG.intervals[state.currentInterval].seconds;
            const progress = (state.countdownSeconds / total) * 283;
            document.getElementById('countdownRing').style.strokeDashoffset = 283 - progress;
        }

        async function triggerAnalysis() {
            console.log('Triggering analysis for', state.currentCrypto);
            
            // Evaluate expired predictions
            const predictions = state.predictions[state.currentCrypto];
            if (predictions) {
                Object.keys(predictions).forEach(interval => {
                    const pred = predictions[interval];
                    if (pred && pred.status === 'ACTIVE' && Date.now() >= pred.expiresAt) {
                        evaluateTrade(pred);
                    }
                });
            }

            // Calculate parameters
            await calculateAllParameters(state.currentCrypto);
            
            // Generate new predictions
            generateAllPredictions();
            
            // Update UI
            updatePredictionCards();
            updateStatsUI();
            updateCharts();

            // Calculate 24h accuracy
            const last24h = state.tradeHistory.filter(t => Date.now() - t.timestamp < 86400000);
            if (last24h.length > 0) {
                state.stats.accuracy24h = (last24h.filter(t => t.actualPL > 0).length / last24h.length) * 100;
            }
        }

        function generateAllPredictions() {
            const params = state.parameters[state.currentCrypto];
            const priceData = state.prices[state.currentCrypto];
            
            if (!params || !priceData) return;
            
            const cps = calculateCPS(params);
            
            if (!state.predictions[state.currentCrypto]) {
                state.predictions[state.currentCrypto] = {};
            }
            
            CONFIG.intervals.forEach(interval => {
                const existing = state.predictions[state.currentCrypto][interval.key];
                if (!existing || existing.status !== 'ACTIVE' || Date.now() >= existing.expiresAt) {
                    const prediction = generatePrediction(priceData.price, cps, interval);
                    executePrediction(prediction, params);
                }
            });
        }

        // ==========================================
        // USER INTERACTIONS
        // ==========================================

        async function selectCrypto(cryptoId) {
            state.currentCrypto = cryptoId;
            renderCryptoTabs();
            
            // Fetch initial klines if not available
            if (!state.klines[cryptoId] || state.klines[cryptoId].length === 0) {
                const interval = CONFIG.intervals[state.currentInterval].bybit;
                const klines = await fetchBybitKlines(cryptoId, interval);
                state.klines[cryptoId] = klines;
            }
            
            // Subscribe to new klines via WebSocket
            subscribeToKlines(cryptoId);
            
            // Calculate parameters
            await calculateAllParameters(cryptoId);
            
            // Generate predictions
            generateAllPredictions();
            
            // Update UI
            updateLivePriceUI();
            updatePredictionCards();
            updateCharts();
        }

        async function selectInterval(index) {
            state.currentInterval = index;
            state.countdownSeconds = CONFIG.intervals[index].seconds;
            document.getElementById('activeInterval').textContent = CONFIG.intervals[index].label + ' INTERVAL';
            renderPredictionCards();
            
            // Fetch new klines for this interval
            const interval = CONFIG.intervals[index].bybit;
            const klines = await fetchBybitKlines(state.currentCrypto, interval);
            state.klines[state.currentCrypto] = klines;
            
            // Recalculate
            await calculateAllParameters(state.currentCrypto);
            generateAllPredictions();
            updateCharts();
        }

        function setChartRange(range) {
            state.currentChartRange = range;
            
            const buttons = document.querySelectorAll('.chart-range-btn');
            buttons.forEach(btn => {
                btn.classList.remove('border', 'border-purple-500', 'bg-white/20');
                btn.classList.add('bg-white/10');
            });
            
            event.target.classList.add('border', 'border-purple-500', 'bg-white/20');
            event.target.classList.remove('bg-white/10');
            
            updateCharts();
        }

        // ==========================================
        // UTILITY FUNCTIONS
        // ==========================================

        function formatPrice(price) {
            if (!price && price !== 0) return '$--';
            if (price >= 1000) {
                return '$' + price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            } else if (price >= 1) {
                return '$' + price.toFixed(2);
            } else {
                return '$' + price.toFixed(4);
            }
        }

        function formatVolume(vol) {
            if (!vol && vol !== 0) return '$--';
            if (vol >= 1e12) return '$' + (vol / 1e12).toFixed(2) + 'T';
            if (vol >= 1e9) return '$' + (vol / 1e9).toFixed(2) + 'B';
            if (vol >= 1e6) return '$' + (vol / 1e6).toFixed(2) + 'M';
            if (vol >= 1e3) return '$' + (vol / 1e3).toFixed(2) + 'K';
            return '$' + vol.toFixed(2);
        }

        function formatNumber(num) {
            if (!num && num !== 0) return '--';
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
            return num.toFixed(2);
        }

        function updateCurrentTime() {
            const now = new Date();
            document.getElementById('currentTime').textContent = now.toLocaleTimeString('en-US', { hour12: false });
        }

        function updateFearGreedUI() {
            const fg = state.fearGreed;
            const fgValueEl = document.getElementById('fgValue');
            const fgLabelEl = document.getElementById('fgLabel');
            const fgCircleEl = document.getElementById('fgCircle');
            
            if (fgValueEl) fgValueEl.textContent = fg.value;
            if (fgLabelEl) fgLabelEl.textContent = fg.classification.toUpperCase();
            
            if (fgCircleEl) {
                const fgOffset = 283 - (fg.value / 100) * 283;
                fgCircleEl.style.strokeDashoffset = fgOffset;
                
                const fgColor = fg.value < 25 ? '#ff3366' : 
                               fg.value < 45 ? '#ff6644' :
                               fg.value < 55 ? '#9945ff' :
                               fg.value < 75 ? '#00dd66' : '#00ff88';
                fgCircleEl.style.stroke = fgColor;
            }
        }

        // ==========================================
        // INITIALIZATION
        // ==========================================

        async function init() {
            console.log('Initializing CryptoOracle Pro with Bybit...');
            const loadingStatus = document.getElementById('loadingStatus');
            
            try {
                // Render static UI elements
                renderCryptoTabs();
                renderPredictionCards();
                initCharts();

                // Fetch initial data for all cryptos
                loadingStatus.textContent = 'Fetching market data...';
                
                for (const crypto of CONFIG.cryptos) {
                    loadingStatus.textContent = `Loading ${crypto.name}...`;
                    
                    // Fetch ticker
                    const ticker = await fetchBybitTicker(crypto.id);
                    if (ticker) {
                        state.prices[crypto.id] = ticker;
                    }
                    
                    // Fetch klines for current interval
                    if (crypto.id === state.currentCrypto) {
                        const interval = CONFIG.intervals[state.currentInterval].bybit;
                        const klines = await fetchBybitKlines(crypto.id, interval);
                        state.klines[crypto.id] = klines;
                    }
                }
                
                // Fetch Fear & Greed
                loadingStatus.textContent = 'Fetching Fear & Greed Index...';
                state.fearGreed = await fetchFearGreedIndex();
                updateFearGreedUI();

                // Calculate initial parameters
                loadingStatus.textContent = 'Calculating indicators...';
                await calculateAllParameters(state.currentCrypto);

                // Generate initial predictions
                loadingStatus.textContent = 'Generating predictions...';
                generateAllPredictions();

                // Update UI
                updateLivePriceUI();
                updateTabPrices();
                updatePredictionCards();
                updateStatsUI();
                updateCharts();

                // Connect WebSocket for real-time data
                loadingStatus.textContent = 'Connecting to live feed...';
                initWebSocket();

                // Hide loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';

                // Start timers
                setInterval(updateCurrentTime, 1000);
                setInterval(updateCountdown, 1000);
                
                // Update predictions every 5 seconds
                setInterval(() => {
                    updatePredictionCards();
                }, 5000);
                
                // Refresh Fear & Greed every 5 minutes
                setInterval(async () => {
                    state.fearGreed = await fetchFearGreedIndex();
                    updateFearGreedUI();
                }, 300000);

                // Full recalculation every minute
                setInterval(async () => {
                    await calculateAllParameters(state.currentCrypto);
                    updateCharts();
                }, 60000);

                console.log('CryptoOracle Pro initialized successfully!');
                
            } catch (error) {
                console.error('Error during initialization:', error);
                document.getElementById('loadingOverlay').innerHTML = `
                    <div class="text-center">
                        <div class="title-font text-xl text-red-400 mb-2">Initialization Failed</div>
                        <div class="text-sm text-gray-400 mb-4">${error.message}</div>
                        <button onclick="location.reload()" class="px-4 py-2 bg-purple-600 rounded hover:bg-purple-700">Retry</button>
                    </div>
                `;
            }
        }

        // Start the application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
